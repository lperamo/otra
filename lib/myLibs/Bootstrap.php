<? namespace bundles\CMS\frontend\controllers; use lib\myLibs\Controller, bundles\CMS\models\MailingList; class ajaxMailingListController extends Controller { public function addAction() { $email = $_POST['email']; if(empty($email)) throw new Lionel_Exception('Missing login !'); $mailingList = new MailingList('mailingTest', 'C\'est une mailing list de sup test 3'); $mailingList->set('id_mailing_list', 10); $mailingList->save(); } } ?>
<?php
 namespace bundles\CMS\frontend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, config\Router; class articleController extends Controller { public function showAction($article = 'article2') { if(!$this->checkCache(array('show.phtml'))) { $db = Session::get('dbConn'); $db->selectDb(); $db->query('SET NAMES UTF8'); if(!isset($_SESSION['headers'])) $_SESSION['headers'] = $db->values($db->query('SELECT * FROM lpcms_header')); if (!isset($_SESSION['footers'])) $_SESSION['footers'] = $db->values($db->query('SELECT * FROM lpcms_footer')); $query = $db->query('SELECT
          m.id, type, position, m.ordre as m_ordre, m.droit as m_droit, m.contenu as m_contenu,
          bemm.fk_id_module as em_fk_id_module, bemm.ordre as em_ordre,
          a.id, titre, a.contenu as a_contenu, a.droit as a_droit, date_creation, cree_par,
            derniere_modif, der_modif_par, derniere_visualisation, der_visualise_par, nb_vu, date_publication,
            meta, rank_sum, rank_count,
          em.id, fk_id_article, parent, aEnfants, em.droit as em_droit,
            em.contenu as em_contenu
        FROM
          lpcms_module m
          LEFT OUTER JOIN lpcms_bind_em_module bemm ON m.id = bemm.fk_id_module
          LEFT OUTER JOIN lpcms_elements_menu em ON bemm.fk_id_elements_menu = em.id
          LEFT OUTER JOIN lpcms_article a ON em.fk_id_article = a.id
        ORDER BY m.position, m.ordre, em_ordre
        '); $result = $db->values($query); unset ($query); $modules = array(); foreach($result as $module) { $position = $module['position']; $typeModule = $module['type']; $mContenu = $module['m_contenu']; unset($module['position'], $module['type'], $module['m_contenu']); $modules[$position][$typeModule][$mContenu][] = $module; } if(file_exists($article = BASE_PATH . 'bundles/' . $this->bundle . '/articles/' . $article . '.html')) { ob_start(); require_once($article); $article = ob_get_clean(); }else $article = 'Cet article n\'existe pas. Cet article n\'existe pas.Cet article n\'existe pas.Cet article n\'existe pas.Cet article n\'existe pas'; echo $this->renderView('show.phtml', array( 'headers' => $_SESSION['headers'], 'footers' => $_SESSION['footers'], 'modules' => $modules, 'lpcms_body' => 'page_t.jpg', 'article' => $article )); }else echo $this->renderView('show.phtml', array()); } } <? namespace bundles\CMS\frontend\controllers; use lib\myLibs\Controller, lib\myLibs\Lionel_Exception, lib\myLibs\Session, \lib\myLibs\Router; class connectionController extends Controller { public function ajaxLoginAction() { $email = $_POST['email']; $pwd = $_POST['pwd']; if(empty($email)) throw new Lionel_Exception('Missing email !'); if(empty($pwd)) throw new Lionel_Exception('Missing password !'); $db = Session::get('dbConn'); $db->selectDb(); $pwd = crypt($pwd, FWK_HASH); $infosUser = ('192.168.1.1' == $_SERVER['REMOTE_ADDR'] || '176.183.7.251' == $_SERVER['REMOTE_ADDR'] || '80.215.41.155' == $_SERVER['REMOTE_ADDR']) ? array( 'id_user' => '-1', 'fk_id_role' => 1) : $db->fetchAssoc($db->query('SELECT u.`id_user`, ur.`fk_id_role` FROM lpcms_user u JOIN lpcms_user_role ur WHERE u.`mail` = \'' . $email . '\' AND u.`pwd` = \'' . $pwd . '\' AND u.id_user = ur.fk_id_user LIMIT 1')); if(empty($infosUser)) echo json_encode(array('fail', 'Bad credentials.')); else { $_SESSION['sid'] = array( 'uid' => $infosUser['id_user'], 'role' => $infosUser['fk_id_role'] ); echo json_encode('success'); } } public function logoutAction() { unset($_SESSION['sid']); Router::get('backend'); } } ?>
<? namespace bundles\CMS\frontend\controllers; use lib\myLibs\Controller; class ajaxArticleController extends Controller { public function showAction($article) { require_once(BASE_PATH . 'bundles/' . $this->bundle . '/articles/' . $article . '.html'); } } ?>
<? namespace bundles\CMS\frontend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session; class indexController extends Controller { public function indexAction() { } } ?>
<?php
 namespace bundles\CMS; use lib\myLibs\Session, lib\myLibs\bdd\Sql; class Init { public static function Init() { Session::set('db', 'CMS'); Session::set('dbConn', Sql::getDB('Mysql')); } } <?php namespace bundles\CMS\backend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, config\Router; class ajaxUsersController extends Controller { public function preExecute(){ if($this->action != 'index' && !isset($_SESSION['sid'])) { Router::get('backend'); die; } } public function indexAction(){ $db = Session::get('dbConn'); $db->selectDb(); $users = $db->values($db->query( 'SELECT u.id_user, u.mail, u.pwd, u.pseudo, r.id_role, r.nom FROM lpcms_user u
      INNER JOIN lpcms_user_role ur ON ur.fk_id_user = u.id_user
      INNER JOIN lpcms_role r ON ur.fk_id_role = r.id_role' )); if(isset($users['id_user'])) $users = array($users); echo $this->renderView('index.phtml', array( 'users' => $users, 'roles' => $db->values($db->query('SELECT id_role, nom FROM lpcms_role ORDER BY nom ASC')) ), true); } public function addAction() { if(!isset($_SESSION['sid']['role']) || 1 !== $_SESSION['sid']['role']) die('Deconnected or lack of rights.'); if(! isset($_POST['mail'], $_POST['pwd'], $_POST['pseudo'], $_POST['role']) || 4 < count($_POST)) die('Hack.'); extract($_POST); $db = Session::get('dbConn'); $db->selectDb(); $dbUsers = $db->query( 'SELECT mail FROM lpcms_user
       WHERE mail = \'' . mysql_real_escape_string($mail) . '\' LIMIT 1' ); $users = $db->values($dbUsers); $db->freeResult($dbUsers); if(is_array($users)) die(json_encode(array('success' => false, 'msg' => 'This mail already exists !'))); $pwd = crypt($pwd, FWK_HASH); $dbError = array('error' => true, 'msg' => 'Database problem !'); if(false === $db->query( 'INSERT INTO lpcms_user (`mail`, `pwd`, `pseudo`) VALUES (\'' . mysql_real_escape_string($mail) . '\', \'' . mysql_real_escape_string($pwd) . '\', \'' . mysql_real_escape_string($pseudo) . '\');' )) die(json_encode($dbError)); $id = $db->lastInsertedId(); die(json_encode((false === $db->query( 'INSERT INTO lpcms_user_role (`fk_id_user`, `fk_id_role`) VALUES (' . $id . ', ' . $role . ');')) ? $dbError : array('success' => true, 'msg' => 'User created.', 'pwd' => $pwd, 'id' => $id))); } public function editAction() { if(!isset($_SESSION['sid']['role']) || 1 !== $_SESSION['sid']['role']) die('Deconnected or lack of rights.'); if(! isset($_POST['id_user'], $_POST['mail'], $_POST['pwd'], $_POST['pseudo'], $_POST['role'], $_POST['oldMail']) || 6 < count($_POST)) die('Hack.'); extract($_POST); $db = Session::get('dbConn'); $db->selectDb(); $dbUsers = $db->query( 'SELECT mail FROM lpcms_user
       WHERE mail = \'' . mysql_real_escape_string($mail) . '\' LIMIT 1' ); $users = $db->values($dbUsers); $db->freeResult($dbUsers); if(is_array($users) && $oldMail != $users[0]['mail']) die('{"success":false,"msg":"This mail already exists !"}'); $pwd = crypt($pwd, FWK_HASH); if(false === $db->query( 'UPDATE lpcms_user SET
      mail = \'' . mysql_real_escape_string($mail) . '\',
      pwd = \'' . mysql_real_escape_string($pwd) . '\',
      pseudo = \'' . mysql_real_escape_string($pseudo) . '\' WHERE id_user = ' . intval($id_user))) die('{"success":false,"msg":"Database problem !"}'); if(false === $db->query( 'UPDATE lpcms_user_role SET
      fk_id_role = ' . intval($role) . '
      WHERE fk_id_user = ' . intval($id_user))) die('{"success":false,"msg":"Database problem !"}'); die('{"success":true,"oldMail":' . $_POST['oldMail'] . ',"msg":"User edited.","pwd","' . $pwd . '"}'); } public function deleteAction() { if(!isset($_SESSION['sid']['role']) || 1 !== $_SESSION['sid']['role']) die('Deconnected or lack of rights.'); if(! isset($_POST['id_user']) || 1 < count($_POST)) die('Hack.'); extract($_POST); $db = Session::get('dbConn'); $db->selectDb(); if(false === $db->query( 'DELETE FROM lpcms_user WHERE `id_user` = ' . intval($id_user))) die('{"success":false,"msg":"Database problem !"}'); if(false === $db->query( 'DELETE FROM lpcms_user_role WHERE fk_id_user = ' . intval($id_user))) die('{"success":false,"msg":"Database problem !"}'); die('{"success":true,"msg":"User deleted."}'); } public function searchAction() { if(!isset($_SESSION['sid']['role']) || 1 !== $_SESSION['sid']['role']) die('Deconnected or lack of rights.'); if(! isset($_POST['type'], $_POST['mail'], $_POST['pseudo'], $_POST['role'], $_POST['limit'], $_POST['prev'], $_POST['last']) || 7 < count($_POST)) die('Hack.'); extract($_POST); $db = Session::get('dbConn'); $db->selectDb(); $limit = intval($limit); $req = 'SELECT u.id_user, u.mail, u.pwd, u.pseudo, r.id_role, r.nom FROM lpcms_user u
      INNER JOIN lpcms_user_role ur ON ur.fk_id_user = u.id_user
      INNER JOIN lpcms_role r ON ur.fk_id_role = r.id_role
      WHERE id_user '; if('search' == $type) $req .= '> ' . (intval($last) - $limit); else $req .= ('next' == $type) ? '> ' . intval($last) : '< ' . intval($prev); if('' != $mail) $req .= ' AND u.mail LIKE \'%' . mysql_real_escape_string($mail) . '%\''; if('' != $pseudo) $req .= ' AND u.pseudo LIKE \'%' . mysql_real_escape_string($pseudo) . '%\''; if('' != $role) $req .= ' AND r.nom LIKE \'%' . mysql_real_escape_string($role) . '%\''; if(false === ($users = $db->query( $req . ' ORDER BY u.id_user ' . (('next' == $type) ? 'LIMIT ' : 'DESC LIMIT ') . $limit ))) die('{"success":false,"msg":"Database problem !"}'); $users = $db->values($users); sort($users); if(isset($users['id_user'])) $users = array($users); end($users); $last = current($users); reset($users); die('{"success":true,"msg":' . json_encode($this->renderView('search.phtml', array('users' => $users), true)) . ',"first":' . $users[0]['id_user'] . ',"last":' . $last['id_user'] . '}'); } } ?>
<?php
 namespace bundles\CMS\backend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, config\Router; class ajaxGeneralController extends Controller { public function preExecute(){ if($this->action != 'index' && !isset($_SESSION['sid'])) { Router::get('backend'); die; } } public function indexAction(){ $db = Session::get('dbConn'); $db->selectDb(); $db->query('SET NAMES UTF8'); echo $this->renderView('index.phtml', array( 'items' => array() ), true); } } ?>
<?php
 namespace bundles\CMS\backend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, config\Router; class ajaxModulesController extends Controller { public static $moduleTypes = array( 0 => 'Connection', 1 => 'Vertical menu', 2 => 'Horizontal menu', 3 => 'Article', 4 => 'Arbitrary' ); public static $rights = array( 0 => 'Admin', 1 => 'Saved', 2 => 'Public' ); public function preExecute(){ if($this->action != 'index' && !isset($_SESSION['sid'])) { Router::get('backend'); die; } } public function indexAction(){ $db = Session::get('dbConn'); $db->selectDb(); $modules = $db->values($db->query('SELECT * FROM lpcms_module')); echo $this->renderView('modules.phtml', array( 'moduleTypes' => self::$moduleTypes, 'right' => self::$rights, 'items' => $modules ), true); } public function searchModuleAction(){ $db = Session::get('dbConn'); $db->selectDb(); echo $this->renderView('modules.phtml', array( 'moduleTypes' => self::$moduleTypes, 'right' => self::$rights, 'items' => $db->values($db->query('
        SELECT id_module, type, position, ordre, droit, contenu
        FROM lpcms_module WHERE contenu LIKE \'%' . mysql_real_escape_string($_GET['search']). '%\'')) ), true); } public function searchElementAction(){ $db = Session::get('dbConn'); $db->selectDb(); echo $this->renderView('elements.phtml', array( 'right' => self::$rights, 'moduleList' => $db->values($db->query('SELECT id_module, contenu FROM lpcms_module')), 'items' => $db->values($db->query('
        SELECT id_elementsmenu, parent, aEnfants, droit, ordre, contenu
        FROM lpcms_elements_menu
        WHERE contenu LIKE \'%' . mysql_real_escape_string($_GET['search']). '%\'')) ), true); } public function searchArticleAction(){ $db = Session::get('dbConn'); $db->selectDb(); $article = $db->values($db->query('SELECT id_article, fk_id_module, titre, contenu, droit, date_creation, cree_par, derniere_modif, der_modif_par, derniere_visualisation, der_visualise_par, nb_vu, date_publication, meta, rank_sum, rank_count
     FROM lpcms_article WHERE contenu LIKE \'%' . mysql_real_escape_string($_GET['search']). '%\'')); var_dump($article);die; } public function getElementsAction(){ $db = Session::get('dbConn'); $db->selectDb(); $element = $db->values($db->query('SELECT id_elementsmenu, fk_id_module, fk_id_article, parent, aEnfants, droit, ordre, contenu
     FROM lpcms_elements_menu WHERE fk_id_module = ' . intval($_GET['id']))); } } ?>
<?php
 namespace bundles\CMS\backend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, config\Router; class ajaxStatsController extends Controller { public function preExecute(){ if($this->action != 'index' && !isset($_SESSION['sid'])) { Router::get('backend'); die; } } public function indexAction(){ $db = Session::get('dbConn'); $db->selectDb(); $db->query('SET NAMES UTF8'); echo $this->renderView('index.phtml', array( 'items' => array() ), true); } } ?>
<?php
 namespace bundles\CMS\backend\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, lib\myLibs\Router; class indexController extends Controller { public function preExecute(){ if($this->action != 'index' && !isset($_SESSION['sid'])){ Router::get('backend'); die; } } public function indexAction() { if(isset($_SESSION['sid'])){ $this->modulesAction(); die; } $db = Session::get('dbConn'); $db->selectDb(); $db->query('SET NAMES UTF8'); if((!isset($_SESSION['headers'])) ) $_SESSION['headers'] = $db->values($db->query('SELECT * FROM lpcms_header')); if (!isset($_SESSION['footers'])) $_SESSION['footers'] = $db->values($db->query('SELECT * FROM lpcms_footer')); echo $this->renderView('index.phtml', array( 'headers' => $_SESSION['headers'], 'footers' => $_SESSION['footers'], 'lpcms_body' => 'page_t.jpg' )); } public function modulesAction() { $db = Session::get('dbConn'); $db->selectDb(); $modules = $db->values($db->query('SELECT * FROM lpcms_module')); echo $this->renderView('modules.phtml', array( 'moduleTypes' => ajaxModulesController::$moduleTypes, 'right' => ajaxModulesController::$rights, 'items' => $modules )); } public function generalAction() { $db = Session::get('dbConn'); $db->selectDb(); $db->query('SET NAMES UTF8'); $_SESSION['js'] = array(); echo $this->renderView('general.phtml', array( 'items' => array() )); } public function statsAction() { $db = Session::get('dbConn'); $db->selectDb(); $db->query('SET NAMES UTF8'); $_SESSION['js'] = array(); echo $this->renderView('stats.phtml', array('items' => array())); } public function usersAction() { $db = Session::get('dbConn'); $db->selectDb(); $users = $db->values($db->query( 'SELECT u.id_user, u.mail, u.pwd, u.pseudo, r.id_role, r.nom FROM lpcms_user u
      INNER JOIN lpcms_user_role ur ON ur.fk_id_user = u.id_user
      INNER JOIN lpcms_role r ON ur.fk_id_role = r.id_role
      ORDER BY id_user
      LIMIT 3' )); if(isset($users['id_user'])) $users = array($users); echo $this->renderView('users.phtml', array( 'users' => $users, 'roles' => $db->values($db->query('SELECT id_role, nom FROM lpcms_role ORDER BY nom ASC')), 'count' => current($db->single($db->query('SELECT COUNT(id_user) FROM lpcms_user'))), 'limit' => 3 )); } } ?>
<?php
 namespace bundles\CMS\models; use lib\myLibs\Model; class MailingList extends Model { protected $table = 'mailing_list', $id_mailing_list, $name, $descr; public function __construct($name, $descr) { $this->name = $name; $this->descr = $descr; } public function addUser() { } } <?php namespace config; define('CACHE_TIME', 300); class All_Config { public static $verbose = 0, $cache_path = CACHE_PATH, $version = 'v1', $dbConnections = array( 'CMS' => array( 'driver' => 'Mysql', 'host' => 'localhost', 'port' => '', 'db' => 'lpcms', 'login' => '_lionel_87', 'password' => 'e94b8f58', 'motor' => 'InnoDB' ) ); } <? namespace config; class Routes { public static $default = array( 'pattern' => '/frontend/index', 'bundle' => 'CMS', 'module' => 'frontend', 'controller' => 'index', 'action' => 'indexAction', 'route' => 'showArticle' ), $_ = array( 'refreshSQLLogs' => array( 'chunks' => array('/dbg/refreshSQLLogs', 'lib\\myLibs', 'core', 'profiler', 'refreshSQLLogsAction'), 'core' => true ), 'clearSQLLogs' => array( 'chunks' => array('/dbg/clearSQLLogs', 'lib\\myLibs', 'core', 'profiler', 'clearSQLLogsAction'), 'core' => true ), 'profiler' => array( 'chunks' => array('/dbg', 'lib\\myLibs', 'core', 'profiler', 'indexAction'), 'core' => true ), 'showArticle' => array( 'chunks' => array('/article/show', 'CMS', 'frontend', 'article', 'showAction'), 'resources' => array( 'template' => true, 'bundle_js' => array('jquery', 'main', 'connection'), 'bundle_css' => array('header', 'footer', 'generic', 'main', 'form') ) ), 'logout' => array( 'chunks' => array('/logout', 'CMS', 'frontend', 'connection', 'logoutAction') ), 'ajaxShowArticle' => array( 'chunks' => array('/ajaxArticle/show', 'CMS', 'frontend', 'ajaxArticle', 'showAction') ), 'ajaxConnection' => array( 'chunks' => array('/ajaxConnection/ajaxLogin', 'CMS', 'frontend', 'connection', 'ajaxLoginAction') ), 'backendModules' => array( 'chunks' => array('/backend/modules', 'CMS', 'backend', 'index', 'modulesAction'), 'resources' => array( '_js' => array('modules'), 'bundle_js' => array('jquery', 'backend'), 'bundle_css' => array('generic', 'interface', 'form') ) ), 'moduleSearch' => array( 'chunks' => array('/backend/ajax/modules/search/module', 'CMS', 'backend', 'ajaxModules', 'searchModuleAction') ), 'elementSearch' => array( 'chunks' => array('/backend/ajax/modules/search/element', 'CMS', 'backend', 'ajaxModules', 'searchElementAction') ), 'articleSearch' => array( 'chunks' => array('/backend/ajax/modules/search/article', 'CMS', 'backend', 'ajaxModules', 'searchArticleAction') ), 'getElements' => array( 'chunks' => array('/backend/ajax/modules/get/elements', 'CMS', 'backend', 'ajaxModules', 'getElementsAction') ), 'backendAjaxModules' => array( 'chunks' => array('/backend/ajax/modules', 'CMS', 'backend', 'ajaxModules', 'indexAction') ), 'backendGeneral' => array( 'chunks' => array('/backend/general', 'CMS', 'backend', 'index', 'generalAction'), 'resources' => array( 'bundle_js' => array('jquery', 'backend'), 'bundle_css' => array('generic', 'interface', 'form') ) ), 'backendStats' => array( 'chunks' => array('/backend/stats', 'CMS', 'backend', 'index', 'statsAction'), 'resources' => array( 'bundle_js' => array('jquery','backend'), 'bundle_css' => array('generic', 'interface', 'form') ) ), 'backendUsers' => array( 'chunks' => array('/backend/users', 'CMS', 'backend', 'index', 'usersAction'), 'resources' => array( '_js' => array('users'), 'bundle_js' => array('jquery', 'backend', 'form', 'notifications'), 'bundle_css' => array('generic', 'interface', 'form', 'notifications') ) ), 'addUser' => array( 'chunks' => array('/backend/ajax/users/add', 'CMS', 'backend', 'ajaxUsers', 'addAction') ), 'editUser' => array( 'chunks' => array('/backend/ajax/users/edit', 'CMS', 'backend', 'ajaxUsers', 'editAction') ), 'deleteUser' => array( 'chunks' => array('/backend/ajax/users/delete', 'CMS', 'backend', 'ajaxUsers', 'deleteAction') ), 'searchUser' => array( 'chunks' => array('/backend/ajax/users/search', 'CMS', 'backend', 'ajaxUsers', 'searchAction') ), 'backendAjaxUsers' => array( 'chunks' => array('/backend/ajax/users', 'CMS', 'backend', 'ajaxUsers', 'indexAction'), 'resources' => array( '_js' => array('users'), 'bundle_css' => array('users') ) ), 'backendAjaxModules' => array( 'chunks' => array('/backend/ajax/modules', 'CMS', 'backend', 'ajaxModules', 'indexAction') ), 'backendAjaxGeneral' => array( 'chunks' => array('/backend/ajax/general', 'CMS', 'backend', 'ajaxGeneral', 'indexAction') ), 'backendAjaxStats' => array( 'chunks' => array('/backend/ajax/stats', 'CMS', 'backend', 'ajaxStats', 'indexAction') ), 'backend' => array( 'chunks' => array('/backend', 'CMS', 'backend', 'index', 'indexAction'), 'resources' => array( 'template' => true, 'bundle_js' => array('jquery', 'main', 'connection'), 'bundle_css' => array('header', 'footer', 'generic', 'main', 'form') ) ), 'index' => array( 'chunks' => array('/', 'CMS', 'frontend', 'article', 'showAction'), 'resources' => array( 'template' => true, 'bundle_js' => array('jquery', 'main', 'connection'), 'bundle_css' => array('header', 'footer', 'generic', 'main', 'form') ) ) ); } <?php namespace config; use lib\myLibs\Session; define('CACHE_PATH', BASE_PATH . 'cache' . DS); define('CMS_VIEWS_PATH', '../bundles/CMS/views/'); define('CMS_CSS_PATH', '/bundles/CMS/resources/css/'); define('CMS_JS_PATH', '/bundles/CMS/resources/js/'); define('CORE_VIEWS_PATH', '../lib/myLibs/core/views'); define('CORE_CSS_PATH', '/lib/myLibs/core/css/'); define('CORE_JS_PATH', '/lib/myLibs/core/js/'); define('LAYOUT', CORE_VIEWS_PATH . DS . 'layout.phtml'); define('VERSION', 'v1'); define('RESOURCE_FILE_MIN_SIZE', 21000); define('FWK_HASH', '$2a$07$ThisoneIsanAwesomeframework$'); require XMODE . DS . 'All_Config.php'; <?php namespace config; define('CACHE_TIME', 300); class All_Config { public static $verbose = 0, $debug = true, $cache = false, $cache_path = CACHE_PATH, $version = 'v1', $dbConnections = array( 'CMS' => array( 'driver' => 'Mysql', 'host' => 'localhost', 'port' => '', 'db' => 'lpcms', 'login' => '_lionel_87', 'password' => 'e94b8f58', 'motor' => 'InnoDB' ) ); } ?>
<?php
 namespace Symfony\Component\Yaml; class Dumper { public function dump($input, $inline = 0, $indent = 0) { $output = ''; $prefix = $indent ? str_repeat(' ', $indent) : ''; if ($inline <= 0 || !is_array($input) || empty($input)) { $output .= $prefix.Inline::dump($input); } else { $isAHash = array_keys($input) !== range(0, count($input) - 1); foreach ($input as $key => $value) { $willBeInlined = $inline - 1 <= 0 || !is_array($value) || empty($value); $output .= sprintf('%s%s%s%s', $prefix, $isAHash ? Inline::dump($key).':' : '-', $willBeInlined ? ' ' : "\n", $this->dump($value, $inline - 1, $willBeInlined ? 0 : $indent + 4) ).($willBeInlined ? "\n" : ''); } } return $output; } } <?php namespace Symfony\Component\Yaml\Tests; use Symfony\Component\Yaml\Yaml; use Symfony\Component\Yaml\Inline; class InlineTest extends \PHPUnit_Framework_TestCase { public function testParse() { foreach ($this->getTestsForParse() as $yaml => $value) { $this->assertEquals($value, Inline::parse($yaml), sprintf('::parse() converts an inline YAML to a PHP structure (%s)', $yaml)); } } public function testDump() { $testsForDump = $this->getTestsForDump(); foreach ($testsForDump as $yaml => $value) { $this->assertEquals($yaml, Inline::dump($value), sprintf('::dump() converts a PHP structure to an inline YAML (%s)', $yaml)); } foreach ($this->getTestsForParse() as $yaml => $value) { $this->assertEquals($value, Inline::parse(Inline::dump($value)), 'check consistency'); } foreach ($testsForDump as $yaml => $value) { $this->assertEquals($value, Inline::parse(Inline::dump($value)), 'check consistency'); } } public function testDumpNumericValueWithLocale() { $locale = setlocale(LC_NUMERIC, 0); if (false === $locale) { $this->markTestSkipped('Your platform does not support locales.'); } $required_locales = array('fr_FR.UTF-8', 'fr_FR.UTF8', 'fr_FR.utf-8', 'fr_FR.utf8', 'French_France.1252'); if (false === setlocale(LC_ALL, $required_locales)) { $this->markTestSkipped('Could not set any of required locales: ' . implode(", ", $required_locales)); } $this->assertEquals('1.2', Inline::dump(1.2)); $this->assertContains('fr', strtolower(setlocale(LC_NUMERIC, 0))); setlocale(LC_ALL, $locale); } public function testHashStringsResemblingExponentialNumericsShouldNotBeChangedToINF() { $value = '686e444'; $this->assertSame($value, Inline::parse(Inline::dump($value))); } protected function getTestsForParse() { return array( '' => '', 'null' => null, 'false' => false, 'true' => true, '12' => 12, '"quoted string"' => 'quoted string', "'quoted string'" => 'quoted string', '12.30e+02' => 12.30e+02, '0x4D2' => 0x4D2, '02333' => 02333, '.Inf' => -log(0), '-.Inf' => log(0), "'686e444'" => '686e444', '686e444' => 646e444, '123456789123456789' => '123456789123456789', '"foo\r\nbar"' => "foo\r\nbar", "'foo#bar'" => 'foo#bar', "'foo # bar'" => 'foo # bar', "'#cfcfcf'" => '#cfcfcf', '2007-10-30' => mktime(0, 0, 0, 10, 30, 2007), '2007-10-30T02:59:43Z' => gmmktime(2, 59, 43, 10, 30, 2007), '2007-10-30 02:59:43 Z' => gmmktime(2, 59, 43, 10, 30, 2007), '"a \\"string\\" with \'quoted strings inside\'"' => 'a "string" with \'quoted strings inside\'', "'a \"string\" with ''quoted strings inside'''" => 'a "string" with \'quoted strings inside\'', '[foo, http://urls.are/no/mappings, false, null, 12]' => array('foo', 'http://urls.are/no/mappings', false, null, 12), '[  foo  ,   bar , false  ,  null     ,  12  ]' => array('foo', 'bar', false, null, 12), '[\'foo,bar\', \'foo bar\']' => array('foo,bar', 'foo bar'), '{foo:bar,bar:foo,false:false,null:null,integer:12}' => array('foo' => 'bar', 'bar' => 'foo', 'false' => false, 'null' => null, 'integer' => 12), '{ foo  : bar, bar : foo,  false  :   false,  null  :   null,  integer :  12  }' => array('foo' => 'bar', 'bar' => 'foo', 'false' => false, 'null' => null, 'integer' => 12), '{foo: \'bar\', bar: \'foo: bar\'}' => array('foo' => 'bar', 'bar' => 'foo: bar'), '{\'foo\': \'bar\', "bar": \'foo: bar\'}' => array('foo' => 'bar', 'bar' => 'foo: bar'), '{\'foo\'\'\': \'bar\', "bar\"": \'foo: bar\'}' => array('foo\'' => 'bar', "bar\"" => 'foo: bar'), '{\'foo: \': \'bar\', "bar: ": \'foo: bar\'}' => array('foo: ' => 'bar', "bar: " => 'foo: bar'), '[foo, [bar, foo]]' => array('foo', array('bar', 'foo')), '[foo, {bar: foo}]' => array('foo', array('bar' => 'foo')), '{ foo: {bar: foo} }' => array('foo' => array('bar' => 'foo')), '{ foo: [bar, foo] }' => array('foo' => array('bar', 'foo')), '[  foo, [  bar, foo  ]  ]' => array('foo', array('bar', 'foo')), '[{ foo: {bar: foo} }]' => array(array('foo' => array('bar' => 'foo'))), '[foo, [bar, [foo, [bar, foo]], foo]]' => array('foo', array('bar', array('foo', array('bar', 'foo')), 'foo')), '[foo, {bar: foo, foo: [foo, {bar: foo}]}, [foo, {bar: foo}]]' => array('foo', array('bar' => 'foo', 'foo' => array('foo', array('bar' => 'foo'))), array('foo', array('bar' => 'foo'))), '[foo, bar: { foo: bar }]' => array('foo', '1' => array('bar' => array('foo' => 'bar'))), ); } protected function getTestsForDump() { return array( 'null' => null, 'false' => false, 'true' => true, '12' => 12, "'quoted string'" => 'quoted string', '12.30e+02' => 12.30e+02, '1234' => 0x4D2, '1243' => 02333, '.Inf' => -log(0), '-.Inf' => log(0), "'686e444'" => '686e444', '.Inf' => 646e444, '"foo\r\nbar"' => "foo\r\nbar", "'foo#bar'" => 'foo#bar', "'foo # bar'" => 'foo # bar', "'#cfcfcf'" => '#cfcfcf', "'a \"string\" with ''quoted strings inside'''" => 'a "string" with \'quoted strings inside\'', '[foo, bar, false, null, 12]' => array('foo', 'bar', false, null, 12), '[\'foo,bar\', \'foo bar\']' => array('foo,bar', 'foo bar'), '{ foo: bar, bar: foo, \'false\': false, \'null\': null, integer: 12 }' => array('foo' => 'bar', 'bar' => 'foo', 'false' => false, 'null' => null, 'integer' => 12), '{ foo: bar, bar: \'foo: bar\' }' => array('foo' => 'bar', 'bar' => 'foo: bar'), '[foo, [bar, foo]]' => array('foo', array('bar', 'foo')), '[foo, [bar, [foo, [bar, foo]], foo]]' => array('foo', array('bar', array('foo', array('bar', 'foo')), 'foo')), '{ foo: { bar: foo } }' => array('foo' => array('bar' => 'foo')), '[foo, { bar: foo }]' => array('foo', array('bar' => 'foo')), '[foo, { bar: foo, foo: [foo, { bar: foo }] }, [foo, { bar: foo }]]' => array('foo', array('bar' => 'foo', 'foo' => array('foo', array('bar' => 'foo'))), array('foo', array('bar' => 'foo'))), ); } } <?php namespace Symfony\Component\Yaml\Tests; use Symfony\Component\Yaml\Yaml; use Symfony\Component\Yaml\Parser; use Symfony\Component\Yaml\Exception\ParseException; class ParserTest extends \PHPUnit_Framework_TestCase { protected $parser; protected function setUp() { $this->parser = new Parser(); } protected function tearDown() { $this->parser = null; } public function testSpecifications($expected, $yaml, $comment) { $this->assertEquals($expected, var_export($this->parser->parse($yaml), true), $comment); } public function getDataFormSpecifications() { $parser = new Parser(); $path = __DIR__.'/Fixtures'; $tests = array(); $files = $parser->parse(file_get_contents($path.'/index.yml')); foreach ($files as $file) { $yamls = file_get_contents($path.'/'.$file.'.yml'); foreach (preg_split('/^---( %YAML\:1\.0)?/m', $yamls) as $yaml) { if (!$yaml) { continue; } $test = $parser->parse($yaml); if (isset($test['todo']) && $test['todo']) { } else { $expected = var_export(eval('return '.trim($test['php']).';'), true); $tests[] = array($expected, $test['yaml'], $test['test']); } } } return $tests; } public function testTabsInYaml() { $yamls = array( "foo:\n	bar", "foo:\n 	bar", "foo:\n	 bar", "foo:\n 	 bar", ); foreach ($yamls as $yaml) { try { $content = $this->parser->parse($yaml); $this->fail('YAML files must not contain tabs'); } catch (\Exception $e) { $this->assertInstanceOf('\Exception', $e, 'YAML files must not contain tabs'); $this->assertEquals('A YAML file cannot contain tabs as indentation at line 2 (near "'.strpbrk($yaml, "\t").'").', $e->getMessage(), 'YAML files must not contain tabs'); } } } public function testEndOfTheDocumentMarker() { $yaml = <<<EOF
--- %YAML:1.0
foo
...
EOF;
$this->assertEquals('foo', $this->parser->parse($yaml)); } public function testObjectsSupport() { $b = array('foo' => new B(), 'bar' => 1); $this->assertEquals($this->parser->parse(<<<EOF
foo: !!php/object:O:30:"Symfony\Component\Yaml\Tests\B":1:{s:1:"b";s:3:"foo";}
bar: 1
EOF
), $b, '->parse() is able to dump objects'); } public function testNonUtf8Exception() { if (!function_exists('mb_detect_encoding')) { $this->markTestSkipped('Exceptions for non-utf8 charsets require the mb_detect_encoding() function.'); return; } $yamls = array( iconv("UTF-8", "ISO-8859-1", "foo: 'äöüß'"), iconv("UTF-8", "ISO-8859-15", "euro: '€'"), iconv("UTF-8", "CP1252", "cp1252: '©ÉÇáñ'") ); foreach ($yamls as $yaml) { try { $this->parser->parse($yaml); $this->fail('charsets other than UTF-8 are rejected.'); } catch (\Exception $e) { $this->assertInstanceOf('Symfony\Component\Yaml\Exception\ParseException', $e, 'charsets other than UTF-8 are rejected.'); } } } } class B { public $b = 'foo'; } <?php namespace Symfony\Component\Yaml\Tests; use Symfony\Component\Yaml\Yaml; use Symfony\Component\Yaml\Parser; use Symfony\Component\Yaml\Dumper; class DumperTest extends \PHPUnit_Framework_TestCase { protected $parser; protected $dumper; protected $path; protected function setUp() { $this->parser = new Parser(); $this->dumper = new Dumper(); $this->path = __DIR__.'/Fixtures'; } protected function tearDown() { $this->parser = null; $this->dumper = null; $this->path = null; } public function testSpecifications() { $files = $this->parser->parse(file_get_contents($this->path.'/index.yml')); foreach ($files as $file) { $yamls = file_get_contents($this->path.'/'.$file.'.yml'); foreach (preg_split('/^---( %YAML\:1\.0)?/m', $yamls) as $yaml) { if (!$yaml) { continue; } $test = $this->parser->parse($yaml); if (isset($test['dump_skip']) && $test['dump_skip']) { continue; } elseif (isset($test['todo']) && $test['todo']) { } else { $expected = eval('return '.trim($test['php']).';'); $this->assertEquals($expected, $this->parser->parse($this->dumper->dump($expected, 10)), $test['test']); } } } } public function testInlineLevel() { $array = array( '' => 'bar', 'foo' => '#bar', 'foo\'bar' => array(), 'bar' => array(1, 'foo'), 'foobar' => array( 'foo' => 'bar', 'bar' => array(1, 'foo'), 'foobar' => array( 'foo' => 'bar', 'bar' => array(1, 'foo'), ), ), ); $expected = <<<EOF
{ '': bar, foo: '#bar', 'foo''bar': {  }, bar: [1, foo], foobar: { foo: bar, bar: [1, foo], foobar: { foo: bar, bar: [1, foo] } } }
EOF;
$this->assertEquals($expected, $this->dumper->dump($array, -10), '->dump() takes an inline level argument'); $this->assertEquals($expected, $this->dumper->dump($array, 0), '->dump() takes an inline level argument'); $expected = <<<EOF
'': bar
foo: '#bar'
'foo''bar': {  }
bar: [1, foo]
foobar: { foo: bar, bar: [1, foo], foobar: { foo: bar, bar: [1, foo] } }

EOF;
$this->assertEquals($expected, $this->dumper->dump($array, 1), '->dump() takes an inline level argument'); $expected = <<<EOF
'': bar
foo: '#bar'
'foo''bar': {  }
bar:
    - 1
    - foo
foobar:
    foo: bar
    bar: [1, foo]
    foobar: { foo: bar, bar: [1, foo] }

EOF;
$this->assertEquals($expected, $this->dumper->dump($array, 2), '->dump() takes an inline level argument'); $expected = <<<EOF
'': bar
foo: '#bar'
'foo''bar': {  }
bar:
    - 1
    - foo
foobar:
    foo: bar
    bar:
        - 1
        - foo
    foobar:
        foo: bar
        bar: [1, foo]

EOF;
$this->assertEquals($expected, $this->dumper->dump($array, 3), '->dump() takes an inline level argument'); $expected = <<<EOF
'': bar
foo: '#bar'
'foo''bar': {  }
bar:
    - 1
    - foo
foobar:
    foo: bar
    bar:
        - 1
        - foo
    foobar:
        foo: bar
        bar:
            - 1
            - foo

EOF;
$this->assertEquals($expected, $this->dumper->dump($array, 4), '->dump() takes an inline level argument'); $this->assertEquals($expected, $this->dumper->dump($array, 10), '->dump() takes an inline level argument'); } public function testObjectsSupport() { $a = array('foo' => new A(), 'bar' => 1); $this->assertEquals('{ foo: !!php/object:O:30:"Symfony\Component\Yaml\Tests\A":1:{s:1:"a";s:3:"foo";}, bar: 1 }', $this->dumper->dump($a), '->dump() is able to dump objects'); } } class A { public $a = 'foo'; } <?php spl_autoload_register(function ($class) { if (0 === strpos(ltrim($class, '/'), 'Symfony\Component\Yaml')) { if (file_exists($file = __DIR__.'/../'.substr(str_replace('\\', '/', $class), strlen('Symfony\Component\Yaml')).'.php')) { require_once $file; } } }); <?php namespace Symfony\Component\Yaml\Exception; class ParseException extends \RuntimeException implements ExceptionInterface { private $parsedFile; private $parsedLine; private $snippet; private $rawMessage; public function __construct($message, $parsedLine = -1, $snippet = null, $parsedFile = null, Exception $previous = null) { $this->parsedFile = $parsedFile; $this->parsedLine = $parsedLine; $this->snippet = $snippet; $this->rawMessage = $message; $this->updateRepr(); parent::__construct($this->message, 0, $previous); } public function getSnippet() { return $this->snippet; } public function setSnippet($snippet) { $this->snippet = $snippet; $this->updateRepr(); } public function getParsedFile() { return $this->parsedFile; } public function setParsedFile($parsedFile) { $this->parsedFile = $parsedFile; $this->updateRepr(); } public function getParsedLine() { return $this->parsedLine; } public function setParsedLine($parsedLine) { $this->parsedLine = $parsedLine; $this->updateRepr(); } private function updateRepr() { $this->message = $this->rawMessage; $dot = false; if ('.' === substr($this->message, -1)) { $this->message = substr($this->message, 0, -1); $dot = true; } if (null !== $this->parsedFile) { $this->message .= sprintf(' in %s', json_encode($this->parsedFile)); } if ($this->parsedLine >= 0) { $this->message .= sprintf(' at line %d', $this->parsedLine); } if ($this->snippet) { $this->message .= sprintf(' (near "%s")', $this->snippet); } if ($dot) { $this->message .= '.'; } } } <?php namespace Symfony\Component\Yaml\Exception; class DumpException extends \RuntimeException implements ExceptionInterface { } <?php namespace Symfony\Component\Yaml\Exception; interface ExceptionInterface { } <?php namespace Symfony\Component\Yaml; use Symfony\Component\Yaml\Exception\ParseException; use Symfony\Component\Yaml\Exception\DumpException; class Inline { const REGEX_QUOTED_STRING = '(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'([^\']*(?:\'\'[^\']*)*)\')'; static public function parse($value) { $value = trim($value); if (0 == strlen($value)) { return ''; } if (function_exists('mb_internal_encoding') && ((int) ini_get('mbstring.func_overload')) & 2) { $mbEncoding = mb_internal_encoding(); mb_internal_encoding('ASCII'); } switch ($value[0]) { case '[': $result = self::parseSequence($value); break; case '{': $result = self::parseMapping($value); break; default: $result = self::parseScalar($value); } if (isset($mbEncoding)) { mb_internal_encoding($mbEncoding); } return $result; } static public function dump($value) { switch (true) { case is_resource($value): throw new DumpException(sprintf('Unable to dump PHP resources in a YAML file ("%s").', get_resource_type($value))); case is_object($value): return '!!php/object:'.serialize($value); case is_array($value): return self::dumpArray($value); case null === $value: return 'null'; case true === $value: return 'true'; case false === $value: return 'false'; case ctype_digit($value): return is_string($value) ? "'$value'" : (int) $value; case is_numeric($value): $locale = setlocale(LC_NUMERIC, 0); if (false !== $locale) { setlocale(LC_NUMERIC, 'C'); } $repr = is_string($value) ? "'$value'" : (is_infinite($value) ? str_ireplace('INF', '.Inf', strval($value)) : strval($value)); if (false !== $locale) { setlocale(LC_NUMERIC, $locale); } return $repr; case Escaper::requiresDoubleQuoting($value): return Escaper::escapeWithDoubleQuotes($value); case Escaper::requiresSingleQuoting($value): return Escaper::escapeWithSingleQuotes($value); case '' == $value: return "''"; case preg_match(self::getTimestampRegex(), $value): case in_array(strtolower($value), array('null', '~', 'true', 'false')): return "'$value'"; default: return $value; } } static private function dumpArray($value) { $keys = array_keys($value); if ((1 == count($keys) && '0' == $keys[0]) || (count($keys) > 1 && array_reduce($keys, function ($v, $w) { return (integer) $v + $w; }, 0) == count($keys) * (count($keys) - 1) / 2) ) { $output = array(); foreach ($value as $val) { $output[] = self::dump($val); } return sprintf('[%s]', implode(', ', $output)); } $output = array(); foreach ($value as $key => $val) { $output[] = sprintf('%s: %s', self::dump($key), self::dump($val)); } return sprintf('{ %s }', implode(', ', $output)); } static public function parseScalar($scalar, $delimiters = null, $stringDelimiters = array('"', "'"), &$i = 0, $evaluate = true) { if (in_array($scalar[$i], $stringDelimiters)) { $output = self::parseQuotedScalar($scalar, $i); } else { if (!$delimiters) { $output = substr($scalar, $i); $i += strlen($output); if (false !== $strpos = strpos($output, ' #')) { $output = rtrim(substr($output, 0, $strpos)); } } elseif (preg_match('/^(.+?)('.implode('|', $delimiters).')/', substr($scalar, $i), $match)) { $output = $match[1]; $i += strlen($output); } else { throw new ParseException(sprintf('Malformed inline YAML string (%s).', $scalar)); } $output = $evaluate ? self::evaluateScalar($output) : $output; } return $output; } static private function parseQuotedScalar($scalar, &$i) { if (!preg_match('/'.self::REGEX_QUOTED_STRING.'/Au', substr($scalar, $i), $match)) { throw new ParseException(sprintf('Malformed inline YAML string (%s).', substr($scalar, $i))); } $output = substr($match[0], 1, strlen($match[0]) - 2); $unescaper = new Unescaper(); if ('"' == $scalar[$i]) { $output = $unescaper->unescapeDoubleQuotedString($output); } else { $output = $unescaper->unescapeSingleQuotedString($output); } $i += strlen($match[0]); return $output; } static private function parseSequence($sequence, &$i = 0) { $output = array(); $len = strlen($sequence); $i += 1; while ($i < $len) { switch ($sequence[$i]) { case '[': $output[] = self::parseSequence($sequence, $i); break; case '{': $output[] = self::parseMapping($sequence, $i); break; case ']': return $output; case ',': case ' ': break; default: $isQuoted = in_array($sequence[$i], array('"', "'")); $value = self::parseScalar($sequence, array(',', ']'), array('"', "'"), $i); if (!$isQuoted && false !== strpos($value, ': ')) { try { $value = self::parseMapping('{'.$value.'}'); } catch (\InvalidArgumentException $e) { } } $output[] = $value; --$i; } ++$i; } throw new ParseException(sprintf('Malformed inline YAML string %s', $sequence)); } static private function parseMapping($mapping, &$i = 0) { $output = array(); $len = strlen($mapping); $i += 1; while ($i < $len) { switch ($mapping[$i]) { case ' ': case ',': ++$i; continue 2; case '}': return $output; } $key = self::parseScalar($mapping, array(':', ' '), array('"', "'"), $i, false); $done = false; while ($i < $len) { switch ($mapping[$i]) { case '[': $output[$key] = self::parseSequence($mapping, $i); $done = true; break; case '{': $output[$key] = self::parseMapping($mapping, $i); $done = true; break; case ':': case ' ': break; default: $output[$key] = self::parseScalar($mapping, array(',', '}'), array('"', "'"), $i); $done = true; --$i; } ++$i; if ($done) { continue 2; } } } throw new ParseException(sprintf('Malformed inline YAML string %s', $mapping)); } static private function evaluateScalar($scalar) { $scalar = trim($scalar); switch (true) { case 'null' == strtolower($scalar): case '' == $scalar: case '~' == $scalar: return null; case 0 === strpos($scalar, '!str'): return (string) substr($scalar, 5); case 0 === strpos($scalar, '! '): return intval(self::parseScalar(substr($scalar, 2))); case 0 === strpos($scalar, '!!php/object:'): return unserialize(substr($scalar, 13)); case ctype_digit($scalar): $raw = $scalar; $cast = intval($scalar); return '0' == $scalar[0] ? octdec($scalar) : (((string) $raw == (string) $cast) ? $cast : $raw); case 'true' === strtolower($scalar): return true; case 'false' === strtolower($scalar): return false; case is_numeric($scalar): return '0x' == $scalar[0].$scalar[1] ? hexdec($scalar) : floatval($scalar); case 0 == strcasecmp($scalar, '.inf'): case 0 == strcasecmp($scalar, '.NaN'): return -log(0); case 0 == strcasecmp($scalar, '-.inf'): return log(0); case preg_match('/^(-|\+)?[0-9,]+(\.[0-9]+)?$/', $scalar): return floatval(str_replace(',', '', $scalar)); case preg_match(self::getTimestampRegex(), $scalar): return strtotime($scalar); default: return (string) $scalar; } } static private function getTimestampRegex() { return <<<EOF
        ~^
        (?P<year>[0-9][0-9][0-9][0-9])
        -(?P<month>[0-9][0-9]?)
        -(?P<day>[0-9][0-9]?)
        (?:(?:[Tt]|[ \t]+)
        (?P<hour>[0-9][0-9]?)
        :(?P<minute>[0-9][0-9])
        :(?P<second>[0-9][0-9])
        (?:\.(?P<fraction>[0-9]*))?
        (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
        (?::(?P<tz_minute>[0-9][0-9]))?))?)?
        $~x
EOF;
} } <?php namespace Symfony\Component\Yaml; use Symfony\Component\Yaml\Exception\ParseException; class Parser { private $offset = 0; private $lines = array(); private $currentLineNb = -1; private $currentLine = ''; private $refs = array(); public function __construct($offset = 0) { $this->offset = $offset; } public function parse($value) { $this->currentLineNb = -1; $this->currentLine = ''; $this->lines = explode("\n", $this->cleanup($value)); if (function_exists('mb_detect_encoding') && false === mb_detect_encoding($value, 'UTF-8', true)) { throw new ParseException('The YAML value does not appear to be valid UTF-8.'); } if (function_exists('mb_internal_encoding') && ((int) ini_get('mbstring.func_overload')) & 2) { $mbEncoding = mb_internal_encoding(); mb_internal_encoding('UTF-8'); } $data = array(); while ($this->moveToNextLine()) { if ($this->isCurrentLineEmpty()) { continue; } if ("\t" === $this->currentLine[0]) { throw new ParseException('A YAML file cannot contain tabs as indentation.', $this->getRealCurrentLineNb() + 1, $this->currentLine); } $isRef = $isInPlace = $isProcessed = false; if (preg_match('#^\-((?P<leadspaces>\s+)(?P<value>.+?))?\s*$#u', $this->currentLine, $values)) { if (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#u', $values['value'], $matches)) { $isRef = $matches['ref']; $values['value'] = $matches['value']; } if (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) { $c = $this->getRealCurrentLineNb() + 1; $parser = new Parser($c); $parser->refs =& $this->refs; $data[] = $parser->parse($this->getNextEmbedBlock()); } else { if (isset($values['leadspaces']) && ' ' == $values['leadspaces'] && preg_match('#^(?P<key>'.Inline::REGEX_QUOTED_STRING.'|[^ \'"\{\[].*?) *\:(\s+(?P<value>.+?))?\s*$#u', $values['value'], $matches) ) { $c = $this->getRealCurrentLineNb(); $parser = new Parser($c); $parser->refs =& $this->refs; $block = $values['value']; if (!$this->isNextLineIndented()) { $block .= "\n".$this->getNextEmbedBlock($this->getCurrentLineIndentation() + 2); } $data[] = $parser->parse($block); } else { $data[] = $this->parseValue($values['value']); } } } elseif (preg_match('#^(?P<key>'.Inline::REGEX_QUOTED_STRING.'|[^ \'"\[\{].*?) *\:(\s+(?P<value>.+?))?\s*$#u', $this->currentLine, $values)) { try { $key = Inline::parseScalar($values['key']); } catch (ParseException $e) { $e->setParsedLine($this->getRealCurrentLineNb() + 1); $e->setSnippet($this->currentLine); throw $e; } if ('<<' === $key) { if (isset($values['value']) && 0 === strpos($values['value'], '*')) { $isInPlace = substr($values['value'], 1); if (!array_key_exists($isInPlace, $this->refs)) { throw new ParseException(sprintf('Reference "%s" does not exist.', $isInPlace), $this->getRealCurrentLineNb() + 1, $this->currentLine); } } else { if (isset($values['value']) && $values['value'] !== '') { $value = $values['value']; } else { $value = $this->getNextEmbedBlock(); } $c = $this->getRealCurrentLineNb() + 1; $parser = new Parser($c); $parser->refs =& $this->refs; $parsed = $parser->parse($value); $merged = array(); if (!is_array($parsed)) { throw new ParseException('YAML merge keys used with a scalar value instead of an array.', $this->getRealCurrentLineNb() + 1, $this->currentLine); } elseif (isset($parsed[0])) { foreach (array_reverse($parsed) as $parsedItem) { if (!is_array($parsedItem)) { throw new ParseException('Merge items must be arrays.', $this->getRealCurrentLineNb() + 1, $parsedItem); } $merged = array_merge($parsedItem, $merged); } } else { $merged = array_merge($merged, $parsed); } $isProcessed = $merged; } } elseif (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#u', $values['value'], $matches)) { $isRef = $matches['ref']; $values['value'] = $matches['value']; } if ($isProcessed) { $data = $isProcessed; } elseif (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) { if ($this->isNextLineIndented()) { $data[$key] = null; } else { $c = $this->getRealCurrentLineNb() + 1; $parser = new Parser($c); $parser->refs =& $this->refs; $data[$key] = $parser->parse($this->getNextEmbedBlock()); } } else { if ($isInPlace) { $data = $this->refs[$isInPlace]; } else { $data[$key] = $this->parseValue($values['value']); } } } else { if (2 == count($this->lines) && empty($this->lines[1])) { try { $value = Inline::parse($this->lines[0]); } catch (ParseException $e) { $e->setParsedLine($this->getRealCurrentLineNb() + 1); $e->setSnippet($this->currentLine); throw $e; } if (is_array($value)) { $first = reset($value); if (is_string($first) && 0 === strpos($first, '*')) { $data = array(); foreach ($value as $alias) { $data[] = $this->refs[substr($alias, 1)]; } $value = $data; } } if (isset($mbEncoding)) { mb_internal_encoding($mbEncoding); } return $value; } switch (preg_last_error()) { case PREG_INTERNAL_ERROR: $error = 'Internal PCRE error.'; break; case PREG_BACKTRACK_LIMIT_ERROR: $error = 'pcre.backtrack_limit reached.'; break; case PREG_RECURSION_LIMIT_ERROR: $error = 'pcre.recursion_limit reached.'; break; case PREG_BAD_UTF8_ERROR: $error = 'Malformed UTF-8 data.'; break; case PREG_BAD_UTF8_OFFSET_ERROR: $error = 'Offset doesn\'t correspond to the begin of a valid UTF-8 code point.'; break; default: $error = 'Unable to parse.'; } throw new ParseException($error, $this->getRealCurrentLineNb() + 1, $this->currentLine); } if ($isRef) { $this->refs[$isRef] = end($data); } } if (isset($mbEncoding)) { mb_internal_encoding($mbEncoding); } return empty($data) ? null : $data; } private function getRealCurrentLineNb() { return $this->currentLineNb + $this->offset; } private function getCurrentLineIndentation() { return strlen($this->currentLine) - strlen(ltrim($this->currentLine, ' ')); } private function getNextEmbedBlock($indentation = null) { $this->moveToNextLine(); if (null === $indentation) { $newIndent = $this->getCurrentLineIndentation(); if (!$this->isCurrentLineEmpty() && 0 == $newIndent) { throw new ParseException('Indentation problem.', $this->getRealCurrentLineNb() + 1, $this->currentLine); } } else { $newIndent = $indentation; } $data = array(substr($this->currentLine, $newIndent)); while ($this->moveToNextLine()) { if ($this->isCurrentLineEmpty()) { if ($this->isCurrentLineBlank()) { $data[] = substr($this->currentLine, $newIndent); } continue; } $indent = $this->getCurrentLineIndentation(); if (preg_match('#^(?P<text> *)$#', $this->currentLine, $match)) { $data[] = $match['text']; } elseif ($indent >= $newIndent) { $data[] = substr($this->currentLine, $newIndent); } elseif (0 == $indent) { $this->moveToPreviousLine(); break; } else { throw new ParseException('Indentation problem.', $this->getRealCurrentLineNb() + 1, $this->currentLine); } } return implode("\n", $data); } private function moveToNextLine() { if ($this->currentLineNb >= count($this->lines) - 1) { return false; } $this->currentLine = $this->lines[++$this->currentLineNb]; return true; } private function moveToPreviousLine() { $this->currentLine = $this->lines[--$this->currentLineNb]; } private function parseValue($value) { if (0 === strpos($value, '*')) { if (false !== $pos = strpos($value, '#')) { $value = substr($value, 1, $pos - 2); } else { $value = substr($value, 1); } if (!array_key_exists($value, $this->refs)) { throw new ParseException(sprintf('Reference "%s" does not exist.', $value), $this->currentLine); } return $this->refs[$value]; } if (preg_match('/^(?P<separator>\||>)(?P<modifiers>\+|\-|\d+|\+\d+|\-\d+|\d+\+|\d+\-)?(?P<comments> +#.*)?$/', $value, $matches)) { $modifiers = isset($matches['modifiers']) ? $matches['modifiers'] : ''; return $this->parseFoldedScalar($matches['separator'], preg_replace('#\d+#', '', $modifiers), intval(abs($modifiers))); } try { return Inline::parse($value); } catch (ParseException $e) { $e->setParsedLine($this->getRealCurrentLineNb() + 1); $e->setSnippet($this->currentLine); throw $e; } } private function parseFoldedScalar($separator, $indicator = '', $indentation = 0) { $separator = '|' == $separator ? "\n" : ' '; $text = ''; $notEOF = $this->moveToNextLine(); while ($notEOF && $this->isCurrentLineBlank()) { $text .= "\n"; $notEOF = $this->moveToNextLine(); } if (!$notEOF) { return ''; } if (!preg_match('#^(?P<indent>'.($indentation ? str_repeat(' ', $indentation) : ' +').')(?P<text>.*)$#u', $this->currentLine, $matches)) { $this->moveToPreviousLine(); return ''; } $textIndent = $matches['indent']; $previousIndent = 0; $text .= $matches['text'].$separator; while ($this->currentLineNb + 1 < count($this->lines)) { $this->moveToNextLine(); if (preg_match('#^(?P<indent> {'.strlen($textIndent).',})(?P<text>.+)$#u', $this->currentLine, $matches)) { if (' ' == $separator && $previousIndent != $matches['indent']) { $text = substr($text, 0, -1)."\n"; } $previousIndent = $matches['indent']; $text .= str_repeat(' ', $diff = strlen($matches['indent']) - strlen($textIndent)).$matches['text'].($diff ? "\n" : $separator); } elseif (preg_match('#^(?P<text> *)$#', $this->currentLine, $matches)) { $text .= preg_replace('#^ {1,'.strlen($textIndent).'}#', '', $matches['text'])."\n"; } else { $this->moveToPreviousLine(); break; } } if (' ' == $separator) { $text = preg_replace('/ (\n*)$/', "\n$1", $text); } switch ($indicator) { case '': $text = preg_replace('#\n+$#s', "\n", $text); break; case '+': break; case '-': $text = preg_replace('#\n+$#s', '', $text); break; } return $text; } private function isNextLineIndented() { $currentIndentation = $this->getCurrentLineIndentation(); $notEOF = $this->moveToNextLine(); while ($notEOF && $this->isCurrentLineEmpty()) { $notEOF = $this->moveToNextLine(); } if (false === $notEOF) { return false; } $ret = false; if ($this->getCurrentLineIndentation() <= $currentIndentation) { $ret = true; } $this->moveToPreviousLine(); return $ret; } private function isCurrentLineEmpty() { return $this->isCurrentLineBlank() || $this->isCurrentLineComment(); } private function isCurrentLineBlank() { return '' == trim($this->currentLine, ' '); } private function isCurrentLineComment() { $ltrimmedLine = ltrim($this->currentLine, ' '); return $ltrimmedLine[0] === '#'; } private function cleanup($value) { $value = str_replace(array("\r\n", "\r"), "\n", $value); if (!preg_match("#\n$#", $value)) { $value .= "\n"; } $count = 0; $value = preg_replace('#^\%YAML[: ][\d\.]+.*\n#su', '', $value, -1, $count); $this->offset += $count; $trimmedValue = preg_replace('#^(\#.*?\n)+#s', '', $value, -1, $count); if ($count == 1) { $this->offset += substr_count($value, "\n") - substr_count($trimmedValue, "\n"); $value = $trimmedValue; } $trimmedValue = preg_replace('#^\-\-\-.*?\n#s', '', $value, -1, $count); if ($count == 1) { $this->offset += substr_count($value, "\n") - substr_count($trimmedValue, "\n"); $value = $trimmedValue; $value = preg_replace('#\.\.\.\s*$#s', '', $value); } return $value; } } <?php namespace Symfony\Component\Yaml; use Symfony\Component\Yaml\Exception\ParseException; class Yaml { static public $enablePhpParsing = false; static public function enablePhpParsing() { self::$enablePhpParsing = true; } static public function parse($input) { $file = ''; if (strpos($input, "\n") === false && is_file($input)) { if (false === is_readable($input)) { throw new ParseException(sprintf('Unable to parse "%s" as the file is not readable.', $input)); } $file = $input; if (self::$enablePhpParsing) { ob_start(); $retval = include($file); $content = ob_get_clean(); $input = is_array($retval) ? $retval : $content; if (is_array($input)) { return $input; } } else { $input = file_get_contents($file); } } $yaml = new Parser(); try { return $yaml->parse($input); } catch (ParseException $e) { if ($file) { $e->setParsedFile($file); } throw $e; } } static public function dump($array, $inline = 2) { $yaml = new Dumper(); return $yaml->dump($array, $inline); } } <?php namespace Symfony\Component\Yaml; class Unescaper { const ENCODING = 'UTF-8'; const REGEX_ESCAPED_CHARACTER = "\\\\([0abt\tnvfre \\\"\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})"; public function unescapeSingleQuotedString($value) { return str_replace('\'\'', '\'', $value); } public function unescapeDoubleQuotedString($value) { $self = $this; $callback = function($match) use($self) { return $self->unescapeCharacter($match[0]); }; return preg_replace_callback('/'.self::REGEX_ESCAPED_CHARACTER.'/u', $callback, $value); } public function unescapeCharacter($value) { switch ($value{1}) { case '0': return "\x0"; case 'a': return "\x7"; case 'b': return "\x8"; case 't': return "\t"; case "\t": return "\t"; case 'n': return "\n"; case 'v': return "\xb"; case 'f': return "\xc"; case 'r': return "\xd"; case 'e': return "\x1b"; case ' ': return ' '; case '"': return '"'; case '/': return '/'; case '\\': return '\\'; case 'N': return $this->convertEncoding("\x00\x85", self::ENCODING, 'UCS-2BE'); case '_': return $this->convertEncoding("\x00\xA0", self::ENCODING, 'UCS-2BE'); case 'L': return $this->convertEncoding("\x20\x28", self::ENCODING, 'UCS-2BE'); case 'P': return $this->convertEncoding("\x20\x29", self::ENCODING, 'UCS-2BE'); case 'x': $char = pack('n', hexdec(substr($value, 2, 2))); return $this->convertEncoding($char, self::ENCODING, 'UCS-2BE'); case 'u': $char = pack('n', hexdec(substr($value, 2, 4))); return $this->convertEncoding($char, self::ENCODING, 'UCS-2BE'); case 'U': $char = pack('N', hexdec(substr($value, 2, 8))); return $this->convertEncoding($char, self::ENCODING, 'UCS-4BE'); } } private function convertEncoding($value, $to, $from) { if (function_exists('iconv')) { return iconv($from, $to, $value); } elseif (function_exists('mb_convert_encoding')) { return mb_convert_encoding($value, $to, $from); } throw new \RuntimeException('No suitable convert encoding function (install the iconv or mbstring extension).'); } } <?php namespace Symfony\Component\Yaml; class Escaper { const REGEX_CHARACTER_TO_ESCAPE = "[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9"; static private $escapees = array('\\\\', '\\"', "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x09", "\x0a", "\x0b", "\x0c", "\x0d", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1f", "\xc2\x85", "\xc2\xa0", "\xe2\x80\xa8", "\xe2\x80\xa9"); static private $escaped = array('\\"', '\\\\', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"); static public function requiresDoubleQuoting($value) { return preg_match('/'.self::REGEX_CHARACTER_TO_ESCAPE.'/u', $value); } static public function escapeWithDoubleQuotes($value) { return sprintf('"%s"', str_replace(self::$escapees, self::$escaped, $value)); } static public function requiresSingleQuoting($value) { return preg_match('/[ \s \' " \: \{ \} \[ \] , & \* \# \?] | \A[ - ? | < > = ! % @ ` ]/x', $value); } static public function escapeWithSingleQuotes($value) { return sprintf("'%s'", str_replace('\'', '\'\'', $value)); } } <? require (('cli' == php_sapi_name()) ? 'prod' : XMODE) . DS . 'Controller.php'; ?>
<?php
 namespace lib\myLibs; use lib\myLibs\Controller, lib\myLibs\Debug_Tools; require_once __DIR__ . '/../../../config/All_Config.php'; class Lionel_Exception extends \Exception { public function __construct($message = 'Error !', $code = '', $file = '', $line = '', $context = '') { $this->message = $message; $this->code = ('' != $code) ? $code : $this->getCode(); $this->file = ('' == $file) ? $this->getFile() : $file; $this->line = ('' == $line) ? $this->getLine() : $line; $this->context = $context; } public function errorMessage() { ob_clean(); $renderController = new Controller(); $renderController->viewPath = CORE_VIEWS_PATH; $renderController::$path = $_SERVER['DOCUMENT_ROOT'] . '..'; if(! empty($this->context)) { unset($this->context['variables']); convertArrayToShowable($this->context, 'Variables'); } return $renderController->renderView('/exception.phtml', array( 'message' =>$this->message, 'code' => $this->code, 'file' => $this->file, 'line' => $this->line, 'context' => $this->context, 'backtraces' => $this->getTrace() ) ); } } <? namespace lib\myLibs; use lib\myLibs\Database, config\All_Config; class Tasks { public static function cc() { array_map('unlink', glob(All_Config::$cache_path . '*.cache')); echo('Cache cleared.' . PHP_EOL); } public static function ccDesc() { return array('Clears the cache'); } public static function crypt(){ require '../config/All_Config.php'; echo crypt($pwd, FWK_HASH), PHP_EOL; } public static function cryptDesc(){ return array('Crypts a password and shows it.', array('password' => 'The password to crypt.'), array('required') ); } public static function genAssets($argv){ require 'GenAssets.php'; } public static function genAssetsDesc(){ return array('Generates one css file and one js file that contain respectively all the minified css files and all the obfuscated minified js files.', array( 'mask' => '1 => templates, 2 => css; 4 => js, => 7 all', 'route' => 'The route for which you want to generate resources.'), array('optional', 'optional') ); } public static function sql() { exec('mysql ../sql/entire_script.sql'); } public static function sqlDesc() { return array('Executes the sql script'); } public static function sql_gb($argv) { Database::init(); if(isset($argv[3])) { $force = 'true' == $argv[3]; Database::createDatabase($argv[2], $force); }else Database::createDatabase($argv[2]); } public static function sql_gbDesc() { return array( 'Database creation, tables creation.(sql_generate_basic)', array ( 'databaseName' => 'The database name !', 'force' => 'If true, we erase the database !' ), array('required', 'optional') ); } public static function sql_gf($argv) { Database::init(); if(isset($argv[3])) { $force = 'true' == $argv[3]; Database::createFixtures($argv[2], $force); }else Database::createFixtures($argv[2]); } public static function sql_gfDesc() { return array( 'Generates fixtures. (sql_generate_fixtures)', array( 'databaseName' => 'The database name !', 'force' => 'If true, we erase the database !' ), array('required', 'optional') ); } public static function routes(){ require '../config/Routes.php'; $alt = 0; foreach(\config\Routes::$_ as $route => $details){ $chunks = $details['chunks']; $altColor = ($alt % 2) ? cyan() : lightBlue(); echo $altColor, PHP_EOL, sprintf('%-25s', $route), str_pad('Url', 10, ' '), ': ' , $chunks[0], PHP_EOL; echo str_pad(' ', 25, ' '), str_pad('Path', 10, ' '), ': ' . $chunks[1] . '/' . $chunks[2] . '/' . $chunks[3] . 'Controller/' . $chunks[4] , PHP_EOL; $shaName = sha1('ca' . $route . All_Config::$version . 'che'); if(isset($details['resources'])) { $resources = $details['resources']; $basePath = substr(__DIR__, 0, -15) . 'cache/'; echo str_pad(' ', 25, ' '), 'Resources : '; if(isset($resources['_css']) || isset($resources['bundle_css']) || isset($resources['module_css'])) echo (file_exists($basePath . 'css' . '/' . $shaName. '.' . 'css.gz')) ? green() : lightRed(), '[CSS]', $altColor; if(isset($resources['_js']) || isset($resources['bundle_js']) || isset($resources['module_js']) || isset($resources['first_js'])) echo (file_exists($basePath . 'js' . '/' . $shaName. '.' . 'js.gz')) ? green() : lightRed(), '[JS]', $altColor; if(isset($resources['template'])) echo (file_exists($basePath . 'tpl' . '/' . $shaName. '.' . 'html.gz')) ? green() : lightRed(), '[TEMPLATE]', $altColor; echo '[', $shaName, ']', PHP_EOL, endColor(); }else echo str_pad(' ', 25, ' '), 'Resources : No resources. ', '[', $shaName, ']', PHP_EOL, endColor(); $alt++; } } public static function routesDesc(){ return array('Shows the routes and their associated kind of resources in the case they have some. (green whether they exists, red otherwise)'); } public static function genClassMap(){ require('GenClassMap.php'); } public static function genClassMapDesc(){ return array('Generates a class mapping file that will be used to replace the autoloading method.'); } public static function genBootstrap($argv) { require('GenBootstrap.php'); } public static function genBootstrapDesc(){ return array( 'Launch the genClassMap command and generates a file that contains all the necessary php files.', array('genClassmap' => 'If set to 0, it prevents the generation/override of the class mapping file.'), array('optional') ); } } ?>

<?php
 namespace lib\myLibs; use config\All_Config; use lib\myLibs\Session; class Model { public function get($property) { return $this->$property; } public function set($property, $value) { $this->$property = $value; } public function save() { $dbName = Session::get('db'); $db = Session::get('dbConn'); $db->selectDb(); $refl = new \ReflectionObject($this); $props = $refl->getProperties(); $properties = array(); foreach($props as $prop) { $name = $prop->name; $properties[$prop->name] = (empty($this->$name)) ? null : $this->$name; if(strpos($name, 'id') !== false) { $id = $name; if(!empty($properties[$name])) $update = true; } } unset($properties['table'], $props, $prop, $refl); if($update) { $query = 'UPDATE `'. All_Config::$dbConnections[$dbName]['db'] . '_' . $this->table . '` SET '; $idValue = $properties[$id]; unset($properties[$id]); foreach($properties as $name => $value) { $query .= '`' . $name . '`=' ; $query .= (is_string($value)) ? '\'' . addslashes($value) . '\',' : $value . ' '; } $query = substr($query, 0, -1) . ' WHERE `'. $id . '`=' . $idValue; }else { unset($properties[$id]); $query = 'INSERT INTO `'. All_Config::$dbConnections[$dbName]['db'] . '_' . $this->table . '` ('; $values = ''; foreach($properties as $name => $value) { $query .= '`' . $name . '`,'; $values .= (is_string($value)) ? '\'' . addslashes($value) . '\',' : $value . ','; } $query = substr($query , 0, -1) . ') VALUES (' . substr($values,0,-1) . ')'; } $db->fetchAssoc($db->query($query)); return $db->lastInsertedId(); } } <?php namespace lib\myLibs; class Session { private static $id; public static function init() { self::$id = \sha1(\time()); } public static function set($key, $value) { $_SESSION[sha1(self::$id .$key)] = $value; } public static function sets(array $array) { foreach($array as $key => $value) $_SESSION[sha1(self::$id .$key)] = $value; } public static function get($key) { return $_SESSION[sha1(self::$id . $key)]; } } ?>
<?php
 namespace lib\myLibs; require_once ROOTPATH . 'lib/myLibs/core/Tasks.php'; class Tasks_Manager { public static function showCommands($message) { echo PHP_EOL , lightRed() , $message, lightGray(), PHP_EOL, PHP_EOL; echo 'The available commmands are : ', PHP_EOL . PHP_EOL, '- ', white(), str_pad('no argument', 25, ' '), lightGray(); echo ': ', cyan(), 'Shows the available commands.', PHP_EOL, PHP_EOL; $methods = get_class_methods('lib\myLibs\Tasks'); foreach ($methods as $method) { if (false === strpos($method, 'Desc')) { $methodDesc = $method . 'Desc'; $paramsDesc = Tasks::$methodDesc(); echo lightGray(), '- ', white(), str_pad($method, 25, ' '), lightGray(), ': ', cyan(), $paramsDesc[0], PHP_EOL; if(isset($paramsDesc[1])) { $i = 0; foreach($paramsDesc[1] as $parameter => $paramDesc) { echo lightBlue(), '   + ', str_pad($parameter, 22, ' '), lightGray(); echo ': ', cyan(), '(', $paramsDesc[2][$i], ') ', $paramDesc, PHP_EOL; ++$i; } } echo PHP_EOL; } } echo endColor(); } public static function execute($command, array $argv) { define('DS', DIRECTORY_SEPARATOR); define('AVT', '..' . DS); if(!file_exists(ROOTPATH . 'lib/myLibs/core/ClassMap.php')) { echo yellow(), 'We cannot use the console if the class mapping file doesn\'t exist ! We launch the generation of this file ...', endColor(), PHP_EOL; Tasks::genClassMap(); } require_once ROOTPATH . 'lib/myLibs/core/ClassMap.php'; spl_autoload_register(function($className) use($classMap){ require $classMap[$className]; }); Tasks::$command($argv); } } ?>
<? namespace lib\myLibs; use lib\myLibs\Controller, config\Routes; class Router { public static function get($route = 'index', $params = array(), $launch = true) { if(!is_array($params)) $params = array($params); extract($chunks = array_combine(array('pattern', 'bundle', 'module', 'controller', 'action'), Routes::$_[$route]['chunks'])); $chunks['route'] = $route; $chunks['css'] = $chunks['js'] = false; if(isset(Routes::$_[$route]['resources'])) { $resources = Routes::$_[$route]['resources']; $chunks['js'] = (isset($resources['bundle_js']) || isset($resources['module_js']) || isset($resources['_js'])); $chunks['css'] = (isset($resources['bundle_css']) || isset($resources['module_css']) || isset($resources['_css'])); } $controller = (isset(Routes::$_[$route]['core']) ? '' : 'bundles\\') . $bundle . '\\' . $module . '\\controllers\\' . $controller . 'Controller'; if($launch) new $controller($chunks, $params); else return Routes::$_[$route] . 'Controller'; } public static function getByPattern($pattern) { foreach(Routes::$_ as $key => $route) { $route = $route['chunks'][0]; if(0 === strpos($pattern, $route)) { $params = explode('/', trim(substr($pattern, strlen($route)), '/')); if('' == $params[0]) return array($key, array()); $derParam = count($params) - 1; $paramsFinal = explode('?', $params[$derParam]); $params[$derParam] = $paramsFinal[0]; return array($key, $params); } } return false; } } <?php namespace lib\myLibs; class Script_Functions { public static function cli($cmd, $verbose = 1) { return (0 < $verbose) ? passthru($cmd) : exec($cmd); } } ?>
<? if(!(isset($argv[2]) && '0' == $argv[2])) require('GenClassMap.php'); require('ClassMap.php'); $content = ''; foreach($classMap as $class) { $content .= file_get_contents($class); } $fp = fopen(ROOTPATH . 'lib/myLibs/core/Bootstrap_comment.php', 'w'); fwrite($fp, $content); fclose($fp); $fp = fopen(ROOTPATH . 'lib/myLibs/core/Bootstrap.php', 'w'); fwrite($fp, php_strip_whitespace(ROOTPATH . 'lib/myLibs/core/Bootstrap_comment.php')); fclose($fp); ?>
<? namespace lib\myLibs\bdd; use lib\myLibs\Lionel_Exception; class Mysql { static private $db; public static function connect($server = 'localhost:3306', $username = 'root', $password = '') { return mysql_connect($server, $username, $password); } public static function selectDb($database_name, $link_identifier) { return mysql_select_db($database_name, $link_identifier); } public static function query($query, $link_identifier) { if (!$result = mysql_query($query, $link_identifier)) { echo(nl2br($query)); throw new Lionel_Exception('Invalid request : ' . mysql_error()); }else return $result; } public static function fetchAssoc($result) { return mysql_fetch_assoc($result); } public static function fetchArray($result, $result_type) { return mysql_fetch_array($result, $result_type); } public static function fetchRow($result) { return mysql_fetch_row($result); } public static function fetchObject($result, $class_name = null, array $params = array()) { return mysql_fetch_object(func_get_args()); } public static function values($result) { if (0 == mysql_num_rows($result)) return false; while ($row = mysql_fetch_assoc($result)) { $results[] = $row; } return $results; } public static function single($result){ if (0 == mysql_num_rows($result)) return false; return mysql_fetch_assoc($result); } public static function freeResult($result) { return mysql_free_result($result); } public static function fetchField($result) { return mysql_fetch_field($result); } public static function close($link_identifier) { return mysql_close(); } public static function lastInsertedId($link_identifier) { return mysql_insert_id($link_identifier); } } ?>
<?php
 namespace lib\myLibs\bdd; use lib\myLibs\Lionel_Exception, lib\myLibs\Session, lib\myLibs\bdd\Mysql, config\All_Config, lib\myLibs\Logger; class Sql { private static $_instance, $_sgbds = array('Mysql'), $_chosenSgbd, $_db, $_link_identifier; public function __construct($sgbd) { self::$_chosenSgbd = __NAMESPACE__ . '\\' . $sgbd; } public function __destruct() { self::close(); } public static function getDB($sgbd) { if(in_array($sgbd, self::$_sgbds)) { if (null == self::$_instance) { self::$_instance = new Sql($sgbd); require($sgbd . '.php'); } extract(All_Config::$dbConnections[Session::get('db')]); self::$_db = $db; $server = ('' == $port) ? $host : $host . ':' . $port; self::$_link_identifier = self::connect($server, $login, $password); return self::$_instance; }else throw new Lionel_Exception('This SGBD doesn\'t exist...yet !', 'E_CORE_ERROR'); } public static function connect($server = 'localhost:3306', $username = 'root', $password = '') { return call_user_func(self::$_chosenSgbd . '::connect', $server, $username, $password); } public function selectDb() { $retour = call_user_func(self::$_chosenSgbd . '::selectDb', self::$_db, self::$_link_identifier); $this->query('SET NAMES UTF8'); return $retour; } public function query($query) { if(isset($_SESSION['debuglp_']) && 'Dev' == $_SESSION['debuglp_']){ $trace = debug_backtrace(); Logger::logSQLTo( (isset($trace[1]['file'])) ? $trace[1]['file'] : $trace[0]['file'], (isset($trace[1]['line'])) ? $trace[1]['line'] : $trace[0]['line'], $query, 'sql'); } return call_user_func(self::$_chosenSgbd . '::query', $query, self::$_link_identifier); } public function fetchAssoc($result) { return call_user_func(self::$_chosenSgbd . '::fetchAssoc', $result); } public function fetchArray($result) { return call_user_func(self::$_chosenSgbd . '::fetchArray', $result); } public static function fetchField($result) { return call_user_func(self::$_chosenSgbd . '::fetchField', $result); } public static function fetchObject($result, $class_name = null, array $params = array() ) { return call_user_func(self::$_chosenSgbd . '::fetchObject', $result, $class_name, $params); } public static function values($result) { return call_user_func(self::$_chosenSgbd . '::values', $result); } public static function single($result){ return call_user_func(self::$_chosenSgbd . '::single', $result); } private static function close() { return call_user_func(self::$_chosenSgbd . '::close', self::$_link_identifier); } public static function freeResult($result) { return call_user_func(self::$_chosenSgbd . '::freeResult', $result); } public static function lastInsertedId() { return call_user_func(self::$_chosenSgbd . '::lastInsertedId', self::$_link_identifier); } } <? namespace lib\myLibs; use config\All_Config, lib\myLibs\MasterController; class Controller extends MasterController { public $viewPath = '/'; private static $cache_used, $css = array(), $js = array(), $rendered = array(); public function checkCache(array $filesToCheck) { foreach($filesToCheck as $fileToCheck) { $templateFile = $this->viewPath . $fileToCheck; $cachedFile = parent::getCacheFileName($templateFile); if (file_exists($cachedFile)) { self::$rendered[$templateFile] = parent::getCachedFile($cachedFile, true); if(!self::$rendered[$templateFile]) return false; }else return false; } return true; } public final function renderView($file, array $variables = array(), $ajax = false, $viewPath = true) { $templateFile = ($viewPath) ? $this->viewPath . $file : $file; if(!file_exists($templateFile)){ require BASE_PATH . '/lib/myLibs/core/Logger.php'; Logger::log('Problem when loading the file : ' . $templateFile); die('Server problem : the file requested doesn\'t exist ! Please wait for the re-establishment of the file, sorry for the inconvenience.'); } self::$cache_used = isset(self::$rendered[$templateFile]) && '' != self::$rendered[$templateFile]; if(self::$cache_used) parent::$template = self::$rendered[$templateFile]; else { $cachedFile = parent::getCacheFileName($templateFile); parent::$template = (!parent::getCachedFile($cachedFile)) ? $this->buildCachedFile($templateFile, $variables, $cachedFile) : parent::getCachedFile(parent::getCacheFileName($templateFile), true); } return parent::$template; } private function buildCachedFile($filename, array $variables, $cachedFile = null, $layout = true) { extract($variables); ob_start(); require $filename; $content = ($layout) ? self::addLayout(ob_get_clean()) : ob_get_clean(); $routeV = $this->route . VERSION; $content = preg_replace('/>\s+</', '><', (!$layout) ? str_replace('/title>', '/title>', $content) : str_replace('/title>', '/title>'. $this->addCss($routeV), $content . $this->addJs($routeV))); self::$js = self::$css = array(); if('cli' == PHP_SAPI) return $content; if(null != $cachedFile) { $fp = fopen($cachedFile, 'w'); fwrite($fp, $content); fclose($fp); } return $content; } private function layout() { $cachedFile = parent::getCacheFileName('layout.phtml', CACHE_PATH, 'CORE_FRAMEWORK'); if(!(parent::$layout = parent::getCachedFile(LAYOUT, $cachedFile))) parent::$layout = $this->buildCachedFile(LAYOUT, array(), $cachedFile, false); } protected static function css($css) { array_splice(self::$css, count(self::$css), 0, (is_array($css)) ? $css : array($css)); } private function addCss($routeV) { $content = ($this->chkCss) ? '<link rel="stylesheet" href="' . parent::getCacheFileName($routeV, '/cache/css/', '', '.gz') . '" />' : ''; if(empty(self::$css)) return $content; $allCss = ''; foreach(self::$css as $css) { $allCss .= file_get_contents(self::$path . $css . '.css'); } if($firstTime) $allCss .= file_get_contents(parent::getCacheFileName($routeV, CACHE_PATH . 'css/', '', '.css')); if(strlen($allCss) < RESOURCE_FILE_MIN_SIZE) return '<style>' . $allCss . '</style>'; $lastFile .= VERSION; $fp = fopen(parent::getCacheFileName($routeV, CACHE_PATH . 'css/', '_dyn', '.css'), 'w'); fwrite($fp, $allCss); fclose($fp); return $content . '<link rel="stylesheet" href="' . parent::getCacheFileName($routeV, '/cache/css/', '_dyn', '.css') . '" />'; } protected static function js($js) { self::$js = array_merge(self::$js, (is_array($js)) ? $js : array($js)); } private function addJs($routeV) { $content = ($this->chkJs) ? '<script src="' . parent::getCacheFileName($routeV, '/cache/js/', '', '.gz') . '" async defer></script>' : ''; if(empty(self::$js)) return $content; $allJs = ''; foreach(self::$js as $js) { $lastFile = $js . '.js'; ob_start(); if(false === strpos($lastFile, ('http'))) echo file_get_contents(parent::$path . $lastFile); else{ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $lastFile); curl_setopt($ch, CURLOPT_HEADER, false); curl_exec($ch); curl_close($ch); } $allJs .= ob_get_clean(); } if($firstTime) $allJs .= file_get_contents(parent::getCacheFileName($routeV, CACHE_PATH . 'js/', '', '.js')); if(strlen($allJs) < RESOURCE_FILE_MIN_SIZE) return '<script async defer>' . $allJs . '</script>'; $lastFile .= VERSION; $fp = fopen(parent::getCacheFileName($routeV, CACHE_PATH . 'js/', '_dyn', '.js'), 'w'); fwrite($fp, $allJs); fclose($fp); return $content . '<script src="' . parent::getCacheFileName($routeV, '/cache/js/', '_dyn', '.js') . '" async defer></script>'; } } <? namespace lib\myLibs\controllers; use lib\myLibs\Controller, lib\myLibs\bdd\Sql, lib\myLibs\Session, config\Router; class profilerController extends Controller { public function preExecute(){ if('Dev' !== $_SESSION['debuglp_']) die('No hacks.'); } public function indexAction($refresh = false) { echo '<div id="profiler">
      <div>
        <a id="dbgHideProfiler" role="button" class="lbBtn dbg_marginR5">Hide the profiler</a>
        <a id="dbgClearSQLLogs" role="button" class="lbBtn dbg_marginR5">Clear SQL logs</a>
        <a id="dbgRefreshSQLLogs" role="button" class="lbBtn">Refresh SQL logs</a><br><br>
      </div>
      <div id="dbgSQLLogs">'; self::writeLogs(BASE_PATH . 'logs/sql.txt'); echo '</div></div>'; } private static function writeLogs($file) { if(file_exists($file) && '' != ($contents = file_get_contents($file))) { $requests = json_decode(substr($contents, 0, -1) . ']', true); foreach($requests as $r) { echo '<div><div class="dbg_leftBlock dbg_fl">In file <span class="dbg_file">', $r['file'], '</span> at line <span class="dbg_line">', $r['line'], '</span>: <p>', $r['query'], '</p></div><a role="button" class="dbg_fr lbBtn">Copy</a></div>'; } }else echo 'No stored queries in ', $file, '.'; } public function clearSQLLogsAction() { $file = BASE_PATH . 'logs/sql.txt'; $handle = fopen($file, 'r+'); ftruncate($handle, 0); fclose($handle); echo 'No more stored queries in ' , $file , '.'; } public function refreshSQLLogsAction() { self::writeLogs(BASE_PATH . 'logs/sql.txt'); } } ?>
<? namespace lib\myLibs; use config\All_Config, lib\myLibs\Logger, config\Routes, lib\myLibs\MasterController; class Controller extends MasterController { public $viewPath = '/'; private static $css = array(), $js = array(), $rendered = array(); public function __construct(array $baseParams = array(), array $getParams = array()){ parent::__construct($baseParams, $getParams); Logger::logTo(PHP_EOL . "\tRoute [" . $this->route . "] Patt : " . $this->pattern, 'trace'); } public function checkCache(array $filesToCheck) { return false; } public final function renderView($file, array $variables = array(), $ajax = false, $viewPath = true) { $templateFile = ($viewPath) ? $this->viewPath . $file : $file; Logger::logTo("\t" . 'Ajax : ' . (($ajax) ? 'true' : 'false'), 'trace'); if (file_exists($templateFile)) parent::$template = $this->buildCachedFile($templateFile, $variables); else throw new Lionel_Exception('Erreur : Fichier non trouvé ! : ' , $templateFile); if(!$ajax) self::addDebugBar(CORE_VIEWS_PATH . DS . 'debugBar.phtml'); return parent::$template; } private function buildCachedFile($filename, array $variables, $cachedFile = null, $layout = true) { extract($variables); ob_start(); require $filename; $content = ($layout && !parent::$layoutOnce) ? parent::addLayout(ob_get_clean()) : ob_get_clean(); Logger::logTo("\t" . 'File : ' . $filename, 'trace'); $content = str_replace( '/title>', '/title>'. self::addCss($layout), $content . self::addJs($layout)); self::$js = self::$css = array(); return $content; } private function addDebugBar($debugBar) { ob_start(); require $debugBar; parent::$template = (false === strpos(parent::$template, 'body')) ? ob_get_clean() . parent::$template : preg_replace('`(<body[^>]*>)`', '$1' . ob_get_clean(), parent::$template); parent::$template = str_replace( '/title>', '/title>'. self::addCss(false), parent::$template . self::addJs(false)); } private function layout() { parent::$layout = $this->buildCachedFile(LAYOUT, array(), null, false); } protected static function css($css = array()) { if(!is_array($css)) $css = array($css); array_splice(self::$css, count(self::$css), 0, $css); } private function addCss($firstTime) { $route = Routes::$_; $debugContent = ''; if($firstTime) { if(isset($route[$this->route])){ $route = $route[$this->route]; if(isset($route['resources'])) { $chunks = $route['chunks']; $resources = $route['resources']; $debLink = "\n" . '<link rel="stylesheet" href="'; $debLink2 = $debLink . '/bundles/'; if(isset($resources['first_css'])) { foreach($resources['first_css'] as $first_css) { $debugContent .= $debLink . $css . '.css" />'; } } if(isset($resources['bundle_css'])) { foreach($resources['bundle_css'] as $bundle_css) { $debugContent .= $debLink2 . $chunks[1] . '/resources/css/' . $bundle_css . '.css" />'; } } if(isset($resources['module_css'])) { foreach($resources['module_css'] as $module_css) { $debugContent .= $debLink2 . $chunks[2] . '/resources/css/' . $module_css . '.css" />'; } } if(isset($resources['_css'])) { foreach($resources['_css'] as $css) { $debugContent .= $debLink . $css . '.css" />'; } } } } } if(empty(self::$css)) return $debugContent; foreach(self::$css as $css) { $debugContent .= "\n" . '<link rel="stylesheet" href="' . $css . '.css" />'; } return $debugContent; } protected static function js($js = array()) { if(!is_array($js)) $js = array($js); self::$js = array_merge(self::$js, $js); } private function addJs($firstTime) { $route = Routes::$_; $debugContent = ''; if($firstTime) { if(isset($route[$this->route])) { $route = $route[$this->route]; if(isset($route['resources'])) { $chunks = $route['chunks']; $resources = $route['resources']; $debLink = "\n" . '<script src="'; $debLink2 = $debLink . '/bundles/'; if(isset($resources['first_js'])) { foreach($resources['first_js'] as $first_js) { $debugContent .= $debLink . $first_js . '.js" ></script>'; } } if(isset($resources['bundle_js'])) { foreach($resources['bundle_js'] as $bundleJs) { $debugContent .= $debLink2 . $chunks[1] . '/resources/js/' . $bundleJs . '.js" ></script>'; } } if(isset($resources['module_js'])) { foreach($resources['module_js'] as $module_js) { $debugContent .= $debLink2 . $chunks[2] . '/resources/js/' . $module_js . '.js" ></script>'; } } if(isset($resources['_js'])) { foreach($resources['_js'] as $js) { $debugContent .= $debLink . $this->viewJSPath . $js . '.js" ></script>'; } } } } } if(empty(self::$js)) return $debugContent; foreach(self::$js as $key => $js) { if(is_int($key)) $key = ''; $debugContent .= "\n" . '<script src="' . $js . '.js" ' . $key . '></script>'; } return $debugContent; } } <? namespace lib\myLibs; use Symfony\Component\Yaml\Parser, Symfony\Component\Yaml\Yaml, config\All_Config; class Database { private static $host = 'localhost', $user = 'root', $pwd = 'e94b8f58', $base = 'test', $motor = 'InnoDB', $command = '', $initCommand = '', $pathSql = '', $pathYml = '', $pathYmlFixtures = '', $databaseFile = 'database_schema', $fixturesFile = 'db_fixture', $fixturesFileIdentifiers = 'ids', $tablesOrderFile = 'tables_order.yml', $attributeInfos = array(); public static function init() { define('VERBOSE', All_Config::$verbose); $dbConn = All_Config::$dbConnections; if(isset($dbConn[key($dbConn)])) { $infosDb = $dbConn[key($dbConn)]; self::$user = $infosDb['login']; self::$pwd = $infosDb['password']; self::$base = $infosDb['db']; if(isset($infosDb['motor'])) self::$motor = $infosDb['motor']; } self::$pathSql = __DIR__ . DS . AVT . AVT . AVT . 'config' . DS . 'data' . DS; self::$pathYml = self::$pathSql . 'yml' . DS; self::$pathYmlFixtures = self::$pathYml . 'fixtures' . DS; self::$pathSql .= 'sql' . DS; self::$tablesOrderFile = self::$pathYml . self::$tablesOrderFile; self::$initCommand = 'mysql --show-warnings -h ' . self::$host . ' -u ' . self::$user . ' --password=' . self::$pwd; $finCommande = ' -e "source ' . self::$pathSql; self::$command = (VERBOSE > 1) ? self::$initCommand . ' -D ' . self::$base . ' -v' . $finCommande : self::$initCommand . ' -D ' . self::$base . $finCommande; self::$initCommand .= (VERBOSE > 1) ? ' -v -e "source ' . self::$pathSql : ' -e "source ' . self::$pathSql; } public static function createDatabase($databaseName, $force = false) { if ($force) { self::dropDatabase($databaseName); self::generateSqlSchema($databaseName, true); Script_Functions::cli(self::$initCommand . self::$databaseFile . '_force.sql "', VERBOSE); } else { self::generateSqlSchema($databaseName, false); Script_Functions::cli(self::$initCommand . self::$databaseFile . '.sql "', VERBOSE); } echo 'Database created.', PHP_EOL; } public static function getAttr($attr, $show = false) { $output = ''; if(isset(self::$attributeInfos[$attr])) { if('notnull' == $attr) $attr = 'not null'; else if('type' == $attr && false !== strpos(self::$attributeInfos[$attr], 'string')) return 'VARCHAR'.substr(self::$attributeInfos[$attr], 6); $output .= ($show) ? ' '.strtoupper($attr) : strtoupper(self::$attributeInfos[$attr]); } return $output; } private static function _sortTableByForeignKeys(array $theOtherTables, &$tables) { $nextArrayToSort = $theOtherTables; foreach($theOtherTables as $key => $properties) { foreach($properties['relations'] as $relation => $relationProperties) { $add = (in_array($relation, $tables)); } if($add) { $tables[] = $key; unset($nextArrayToSort[$key]); } } if(0 < count($nextArrayToSort)) self::_sortTableByForeignKeys ($nextArrayToSort, $tables); } public static function createFixture($databaseName, $file, array $schema, array $sortedTables, &$fixtureMemory = array(), $force = false) { $fixturesData = Yaml::parse($file); $createdFiles = array(); $first = true; foreach ($fixturesData as $table => $names) { $createdFile = self::$pathSql . self::$fixturesFile . '_' . $databaseName . '_' . $table . '.sql'; $createdFiles [$table]= $createdFile; $localMemory = array(); $ymlIdentifiers = $table . ': ' . PHP_EOL; if($force) self::truncateTable($databaseName, $table); if (!file_exists($createdFile)) { $tableSql = 'USE ' . $databaseName . ';' . PHP_EOL . 'SET NAMES UTF8;' . PHP_EOL . PHP_EOL . 'INSERT INTO `' . $table . '` ('; $values = $properties = array(); $theProperties = ''; if(isset($schema[$table]['relations'])) { foreach(array_keys($schema[$table]['relations']) as $relation) { $datas = Yaml::parse(self::$pathYmlFixtures . self::$fixturesFileIdentifiers . DS . $databaseName . '_' . $relation . '.yml'); foreach($datas as $key => $data) { $fixturesMemory[$key] = $data; } } } $i = 1; foreach($names as $name => $properties) { ksort($properties); $ymlIdentifiers .= '  ' . $name . ': ' . $i++ . PHP_EOL; $localMemory[$name] = $i; $theValues = ''; foreach ($properties as $property => $value) { if ($first) $theProperties .= (in_array($property, $sortedTables)) ? '`' . $schema[$table]['relations'][$property]['local'] . '`, ' : '`' . $property . '`, '; $properties [] = $property; if (!in_array($property, $sortedTables)) { if(null === $value) { $tmp = $schema[$table]['columns'][$property]; $tmpBool = isset($tmp['notnull']); if(!$tmpBool || ($tmpBool && false === $tmp['notnull'])) { if (false !== strpos($tmp['type'], 'string')) $value = ' '; switch($tmp['type']) { case 'timestamp' : case 'integer' : $value = 0; break; } } }else if(is_bool($value)) $value = ($value) ? 1 : 0; else if(is_string($value) && 'integer' == $schema[$table]['columns'][$property]['type']) $value = $localMemory[$value]; $theValues .= (is_string($value)) ? '\''.addslashes($value) . '\', ' : $value . ', '; } else $theValues .= $fixturesMemory[$property][$value] . ', '; $values [] = array($name => $value); } if ($first) $tableSql .= substr($theProperties, 0, -2) . ') VALUES'; $tableSql .= '(' . substr($theValues, 0, -2) . '),'; $first = false; } $tableSql = substr($tableSql, 0, -1) . ';'; $fp = fopen($createdFile, 'x' ); fwrite($fp, $tableSql); fclose($fp); echo 'File created : ', self::$fixturesFile, '_', $databaseName, '_', $table, '.sql', PHP_EOL; $fp = fopen(self::$pathYmlFixtures . self::$fixturesFileIdentifiers . DS . $databaseName . '_' . $table . '.yml', 'w' ); fwrite($fp, $ymlIdentifiers); fclose($fp); }else echo 'Aborted : the file ' , self::$fixturesFile, '_' , $databaseName , '_' , $table, ',sql', ' already exists.', PHP_EOL; } } public static function createFixtures($databaseName, $force = false) { $folder = ''; if ($folder = opendir(self::$pathYmlFixtures)) { $schema = Yaml::parse(self::$pathYml . 'schema.yml'); $tablesOrder = Yaml::parse(self::$tablesOrderFile); $tablesToCreate = array(); while(false !== ($file = readdir($folder))) { if ($file != '.' && $file != '..' && $file != '') { $file = self::$pathYmlFixtures . $file; if (!is_dir($file)) { $tables = self::analyzeFixtures($file); foreach ($tables as $table => $file) { $tablesToCreate[$databaseName][$table] = $file; } } } } foreach($tablesOrder as $table) { for ($i = 0, $cptTables = count($tablesToCreate[$databaseName]); $i < $cptTables; $i += 1) { if(isset($tablesToCreate[$databaseName][$table])) { $file = $tablesToCreate[$databaseName][$table]; self::createFixture($databaseName, $file, $schema, $tablesOrder, $fixtureMemory, $force); self::executeFixture($databaseName, $table, $file); break; } } } die; } } public static function executeFixture($databaseName, $table) { Script_Functions::cli(self::$initCommand . self::$fixturesFile . '_' . $databaseName .'_' . $table . '.sql "', VERBOSE); } public static function dropDatabase($databaseName) { $file = 'drop_' . $databaseName.'.sql'; $pathAndFile = self::$pathSql . $file; if (!file_exists($pathAndFile)) { exec('echo DROP DATABASE IF EXISTS ' . $databaseName . '; > ' . $pathAndFile); echo '\'Drop database\' file created.' , PHP_EOL; } Script_Functions::cli(self::$initCommand . $file . '"', VERBOSE); echo 'Database dropped.', PHP_EOL; } public static function generateSqlSchema($databaseName, $force = false) { $dbFile = ($force) ? self::$pathSql.self::$databaseFile . '_force.sql' : self::$pathSql.self::$databaseFile . '.sql'; if (!file_exists($dbFile)) { echo 'The \'sql schema\' file doesn\'t exist. Creates the file...', PHP_EOL; $sql = ($force) ? 'CREATE DATABASE ' : 'CREATE DATABASE IF NOT EXISTS '; $sql .= $databaseName . ';' . PHP_EOL . PHP_EOL . 'USE ' . $databaseName . ';' . PHP_EOL . PHP_EOL; $schema = Yaml::parse(self::$pathYml . 'schema.yml'); $theOtherTables = $sortedTables = array(); $constraints = ''; $tableSql = array(); foreach($schema as $table => $properties) { $primaryKeys = array(); $defaultCharacterSet = ''; $tableSql[$table] = 'DROP TABLE IF EXISTS `' . $table . '`;' . PHP_EOL . 'CREATE TABLE `' . $table . '` (' . PHP_EOL; foreach($properties as $property => $attributes) { if('columns' == $property) { foreach ($attributes as $attribute => $informations) { self::$attributeInfos = $informations; $tableSql[$table] .= '  `' . $attribute . '` ' . self::getAttr('type') . self::getAttr('notnull', true) . self::getAttr('auto_increment', true) . ',' . PHP_EOL; if('' != self::getAttr('primary')) $primaryKeys[] = $attribute; } }else if('relations' == $property) { foreach ($attributes as $otherTable => $attribute) { $onDelete = ''; if(isset($attribute['onDelete'])) $onDelete = '  ON DELETE '.strtoupper ($attribute['onDelete']); $constraints .= 'ALTER TABLE ' . $table . ' ADD CONSTRAINT ' . $attribute['constraint_name'] . ' FOREIGN KEY(' . $attribute['local'] . ')' . PHP_EOL; $constraints .= '  REFERENCES ' . $otherTable . '(' . $attribute['foreign'] . ')' . PHP_EOL . $onDelete . ';' . PHP_EOL; } }else if('indexes' == $property) { }else if('default_character_set' == $property) { $defaultCharacterSet = $attributes; } } unset($property, $attributes, $informations, $otherTable, $attribute); if(empty($primaryKeys)) echo 'NOTICE : There isn\'t primary key in ', $table, '!', PHP_EOL; else { $primaries = '`'; foreach ($primaryKeys as $primaryKey) { $primaries .= $primaryKey.'`, `'; } $tableSql[$table] .= '  PRIMARY KEY(' . substr($primaries, 0, -3) . ') '. PHP_EOL; } unset($primaries, $primaryKey); $tableSql[$table] .= ('' == $defaultCharacterSet) ? ') ENGINE=' . self::$motor . ' DEFAULT CHARACTER SET utf8' : ') ENGINE=' . self::$motor . ' DEFAULT CHARACTER SET ' . $defaultCharacterSet; $tableSql[$table] .= ';' . PHP_EOL . PHP_EOL; if(isset($properties['relations'])) $theOtherTables[$table] = $schema[$table]; else $sortedTables[] = $table; } self::_sortTableByForeignKeys($theOtherTables, $sortedTables); $tablesOrder = ''; $storeSortedTables = ($force || !file_exists(self::$tablesOrderFile)); foreach($sortedTables as $sortedTable) { if ($storeSortedTables) $tablesOrder .= '- ' . $sortedTable . PHP_EOL; $sql .= $tableSql[$sortedTable]; } if($storeSortedTables) { $fp = fopen(self::$tablesOrderFile, 'w' ); fwrite($fp, $tablesOrder); fclose($fp); echo '\'Tables order\' file created.' , PHP_EOL; } $fp = fopen($dbFile, 'w'); fwrite($fp, $sql); fclose($fp); echo '\'SQL schema\' file created.', PHP_EOL; }else echo 'The \'SQL schema\' file already exists.', PHP_EOL; } public static function truncateTable($databaseName, $tableName) { $file = 'truncate_' . $databaseName . '_' . $tableName . '.sql'; $pathAndFile = self::$pathSql . $file; if (!file_exists($pathAndFile)) { $fp = fopen($pathAndFile, 'x'); fwrite($fp, 'USE '. $databaseName . ';' . PHP_EOL . 'TRUNCATE TABLE ' . $tableName . ';'); fclose($fp); echo '\'Truncate table\' file created.' , PHP_EOL; } Script_Functions::cli(self::$initCommand . $file . '"', VERBOSE); echo 'Table truncated.', PHP_EOL; } private static function analyzeFixtures($file) { $fixturesData = Yaml::parse($file); foreach (array_keys($fixturesData) as $table) { $tablesToCreate[$table]= $file; } return $tablesToCreate; } } ?>
<?php
namespace lib\myLibs; class Logger { private static function logIpTest() { $_SESSION['_date'] = $_SESSION['_ip'] = $_SESSION['_browser'] = ''; if(!isset($_SESSION['_date'])) $_SESSION['_date'] = $_SESSION['_ip'] = $_SESSION['_browser'] = ''; $infos = ''; $date = date(DATE_ATOM, time()); if($date != $_SESSION['_date']) $infos .= '[' . ($_SESSION['_date'] = $date) . '] '; if($_SERVER['REMOTE_ADDR'] != $_SESSION['_ip']) $infos .= $infos . '[' . ($_SESSION['_ip'] = $_SERVER['REMOTE_ADDR']) . '] '; if($_SERVER['HTTP_USER_AGENT'] != $_SESSION['_browser']) return $infos . '[' . ($_SESSION['_browser'] = $_SERVER['HTTP_USER_AGENT']) . '] '; return $infos; } public static function log($message) { error_log(self::logIpTest() . $message . "\n", 3, __DIR__ . '/../../../logs/log.txt'); } public static function logToPath($message, $path = '') { error_log(self::logIpTest() . $message . "\n", 3, __DIR__ . $path . '.txt'); } public static function logTo($message, $path = '') { error_log(self::logIpTest() . $message . "\n", 3, __DIR__ . '/../../../logs/' . $path . '.txt'); } public static function logSQLTo($file, $line, $message, $path = '') { $path = __DIR__ . '/../../../logs/' . $path . '.txt'; error_log(((! ($content = file_get_contents($path)) || '' == $content) ? '[' : '') . '{"file":"' . $file . '","line":' . $line . ',"query":"' . preg_replace('/\s\s+/', ' ', str_replace(array("\r", "\r\n", "\n"), '', trim($message))) . '"},', 3, $path); } } ?>
<? namespace lib\myLibs; class MasterController{ public static $path; protected $bundle = '', $module = '', $controller = '', $action = '', $route, $getParams = '', $viewCSSPath = '/', $viewJSPath = '/', $pattern = ''; protected static $id, $template, $layout, $body, $bodyAttrs, $layoutOnce = false; public function __construct(array $baseParams = array(), array $getParams = array()) { if(isset($baseParams['controller'])) { list($this->pattern, $this->bundle, $this->module, $this->controller, , $this->route, $this->chkJs, $this->chkCss) = array_values($baseParams); $this->action = substr($baseParams['action'], 0, -6); self::$id = $this->bundle . $this->module . $this->controller . $this->action; $this->getParams = $getParams; $mainPath = '/bundles/' . $this->bundle . '/' . $this->module . '/'; $this->viewPath = BASE_PATH . $mainPath . 'views/' . $this->controller . '/'; $this->viewCSSPath = $mainPath .'resources/css/'; $this->viewJSPath = $mainPath . 'resources/js/'; self::$path = $_SERVER['DOCUMENT_ROOT'] . '..'; $this->preExecute(); call_user_func_array(array($this, $baseParams['action']), $getParams); } } public function preExecute(){} protected static function getCacheFileName($filename, $path = CACHE_PATH, $prefix = '', $extension = '.cache') { return $path . sha1('ca' . $prefix . $filename . 'che') . $extension; } protected static function getCachedFile($cachedFile, $exists = false) { if(($exists || file_exists($cachedFile)) && (filemtime($cachedFile) + CACHE_TIME) > time()) return file_get_contents ($cachedFile); return false; } protected static function addLayout($content) { if(isset(self::$layout)) { self::$layoutOnce = true; return preg_replace('`(<body[^>]*>)(.*)`s', '$1' . str_replace('$','\\$', $content), self::$layout); }else return $content; } public static function bodyAttrs($attrs = '') { self::$bodyAttrs = $attrs; } private static function body($content = '') { self::$body = $content; } protected static function title($title) { self::$layout = (isset(self::$layout)) ? preg_replace('@(<title>)(.*)(</title>)@', '$1' . $title . '$3', self::$layout) : '<title>' . $title . '</title><body>'; } protected static function favicon($filename = '', $filenameIE = '') { echo '<link rel="icon" type="image/png" href="' , $filename , '" />
      <!--[if IE]><link rel="shortcut icon" type="image/x-icon" href="' , $filenameIE . '" /><![endif]-->'; } } <? $_SESSION['debuglp_'] = 'Dev'; define ('BEFORE', microtime(true)); define('BASE_PATH', substr(__DIR__, 0, -15)); require '../lib/myLibs/core/Debug_Tools.php'; if('out' == $_GET['d']) unset($_SESSION['debuglp_']); use lib\myLibs\Router, config\Routes, lib\myLibs\Lionel_Exception, config\All_Config; ob_start(); define('DS', DIRECTORY_SEPARATOR); ini_set('display_errors', 1); ini_set('html_errors', 1); ini_set('error_reporting', -1); error_reporting(-1); require BASE_PATH . 'lib/myLibs/core/ClassMap.php'; spl_autoload_register(function($className) use($classMap){ require $classMap[$className]; }); function errorHandler($errno, $message, $file, $line, $context) { throw new Lionel_Exception($message, $errno, $file, $line, $context); } set_error_handler('errorHandler'); define('XMODE', 'dev'); ob_get_clean(); function t($texte){ echo $texte; } try{ header('Content-Type: text/html; charset=utf-8'); header("Vary: Accept-Encoding,Accept-Language"); if($route = Router::getByPattern($_SERVER['REQUEST_URI'])) { call_user_func('bundles\\' . Routes::$default['bundle'] . '\\Init::Init'); Router::get($route[0], $route[1]); } }catch(Exception $e){ echo $e->errorMessage(); return false; } <? $dirs = array('bundles', 'config', 'lib'); $classes = array(); $processedDir = 0; foreach ($dirs as $dir){ list($classes, $processedDir) = iterateCM($classes, ROOTPATH . $dir, $processedDir); } ob_start(); var_export($classes); $classMap = ob_get_clean(); $fp = fopen(ROOTPATH . 'lib/myLibs/core/ClassMap.php', 'w'); fwrite($fp, '<? $classMap = ' . substr(str_replace(array('\\\\', ' ', "\n"), array('\\', '', ''), $classMap), 0, -2) . ');'); fclose($fp); echo PHP_EOL, green() , 'Class mapping finished.', endColor(), PHP_EOL; var_dump($classMap); echo PHP_EOL;die; function iterateCM($classes, $dir, $processedDir) { if ($handle = opendir($dir)) { while (false !== ($entry = readdir($handle))) { if('.' == $entry || '..' == $entry) continue; $_entry = $dir . DS . $entry; if(is_dir($_entry)) list($classes, $processedDir) = iterateCM($classes, $_entry, $processedDir); $posDot = strrpos($entry, "."); if('.php' != (substr($entry, $posDot) )) continue; $classes[substr(str_replace('/', '\\', $dir), strlen(ROOTPATH)) . '\\' . substr($entry, 0, $posDot)] = $_entry; } closedir($handle); $processedDir += 1; echo "\x0d\033[K", 'Processed directories : ', $processedDir, '...'; return array($classes, $processedDir); } die ('Problem encountered with the directory : ' . $dir . ' !'); } <? function lg($message){ require_once __DIR__ . '/Logger.php'; lib\myLibs\Logger::logTo($message, 'trace'); }; function dump() { echo '<pre>'; foreach (func_get_args() as $param) { var_dump(is_string($param) ? htmlspecialchars($param) : $param); echo '<br />'; } echo '</pre>'; } function reformatSource($stringToFormat) { return preg_replace('@&gt;\s*&lt;@', "&gt;<br/>&lt;", htmlspecialchars($stringToFormat)); } function convertArrayToShowable(&$dataToShow, $title, $indexToExclude = null){ ob_start();?>
    <table class="radius test">
      <thead>
        <tr class="head">
          <th colspan="3"><?= $title ?></th>
        </tr>
        <tr class="head">
          <th>Name</th>
          <th>Index or value if array</th>
          <th>Value if array</th>
        </tr>
      </thead>
      <tbody>
    <? recurArrayConvertTab($dataToShow, $indexToExclude); ?></tbody></table><? $dataToShow = ob_get_clean(); } function recurArrayConvertTab($donnees, $indexToExclude = null, $boucle = -1){ $i = 0; $oldBoucle = $boucle; ++$boucle; foreach($donnees as $index => &$donnee) { if($index === $indexToExclude) { continue; } if($boucle == 0) { echo '</tbody></table><table class="test"><tbody>'; } if(is_array($donnee) || is_object($donnee)) { if(1 == $boucle){ if($boucle < $oldBoucle){ echo '<tr class="foldable"><td colspan="' , $boucle , '"></td><td>\'' , $index, '\'</td></tr>'; } else echo '<td>\'' , $index, '\'</td><td colspan="0" class="dummy"></td></tr>'; }else if($boucle > 1) echo '<tr class="foldable"><td colspan="', $boucle, '"></td><td colspan="0">\'' , $index, '\'</td><td colspan="0" class="dummy"></td></tr>'; else echo '<tr class="foldable"><td>\'' , $index, '\'</td>'; $oldBoucle = recurArrayConvertTab($donnee, $indexToExclude, $boucle); }else { if(0 == $boucle){ echo '<tr class="foldable" ><td>\'', $index, '\'</td><td colspan="2">\'', $donnee , '\'</td></tr>'; }else{ if(is_object($donnee)) $donnee = 'This is an Object non renderable !!'; echo '<tr class="deepContent"><td colspan="' , $boucle , '"></td><td>\'', $index, '\'</td><td>\'', $donnee , '\'</td></tr>'; } } $i += 1; } return $oldBoucle; } function debug($noErrors = true){ if($noErrors) error_reporting(0); return (isset($_SESSION['debuglp_']) && $_SESSION['debuglp_'] == 'Dev');} ?>
<? define('BASE_PATH', substr(__DIR__, 0, -16)); require BASE_PATH . '/config/Routes.php'; require BASE_PATH . '/lib/myLibs/core/Router.php'; require_once BASE_PATH . '/config/All_Config.php'; require BASE_PATH . '/lib/packerjs/JavaScriptPacker.php'; $routes = \config\Routes::$_; if(isset($argv[3])) { $theRoute = $argv[3]; if(isset($routes[$theRoute])){ echo PHP_EOL, 'Cleaning the resources cache...'; $mask = (isset($argv[2])) ? $argv[2] + 0 : 7; $routes = array($theRoute => $routes[$theRoute]); $shaName = sha1('ca' . $theRoute . VERSION . 'che'); if($mask & 1){ $file = CACHE_PATH . 'tpl/' . $shaName . '.gz'; if(file_exists($file)) unlink($file); } if(($mask & 2) >> 1) { $file = CACHE_PATH . 'css/' . $shaName . '.gz'; if(file_exists($file)) unlink($file); } if(($mask & 4) >> 2) { $file = CACHE_PATH . 'js/' . $shaName . '.gz'; if(file_exists($file)) unlink($file); } echo green(), ' OK', PHP_EOL, endColor(); } else dieC('yellow', PHP_EOL . 'This route doesn\'t exist !' . PHP_EOL); }else { echo PHP_EOL, 'Cleaning the resources cache...'; $mask = (isset($argv[2])) ? $argv[2] + 0 : 7; if($mask & 1) array_map('unlink', glob(\Config\All_Config::$cache_path . '/tpl/*')); if(($mask & 2) >> 1) array_map('unlink', glob(\Config\All_Config::$cache_path . '/css/*')); if(($mask & 4) >> 2) array_map('unlink', glob(\Config\All_Config::$cache_path . '/js/*')); echo green(), ' OK', PHP_EOL, endColor(); } $cptRoutes = count($routes); echo $cptRoutes , ' route(s) to process. Processing the route(s) ... ' . PHP_EOL; for($i = 0; $i < $cptRoutes; $i += 1){ $route = current($routes); $name = key($routes); next($routes); echo lightBlue(), str_pad($name, 25, ' '), lightGray(); if(!isset($route['resources'])){ echo status('Nothing to do', 'cyan'), ' =>', green(), ' OK', endColor(), PHP_EOL; continue; } $resources = $route['resources']; $chunks = $route['chunks']; $shaName = sha1('ca' . $name . VERSION . 'che'); $bundlePath = BASE_PATH . '/bundles/' . $chunks[1] . '/'; if(($mask & 2) >> 1) echo css($shaName, $chunks, $bundlePath, $resources); if(($mask & 4) >> 2) echo js($shaName, $chunks, $bundlePath, $resources); if($mask & 1) echo template($shaName, $name, $resources); echo ' => ', green(), 'OK ', endColor(), '[', cyan(), $shaName, endColor(), ']', PHP_EOL; } function status($status, $color = 'green'){ return ' [' . $color() . $status . lightGray(). ']'; } function cleanCss($content) { $content = preg_replace('@/\*.*?\*/@s', '', $content); $content = str_replace(array("\r\n", "\r", "\n", "\t", '  '), '', $content); $content = str_replace(array('{ ',' {'), '{', $content); $content = str_replace(array(' }','} '), '}', $content); $content = str_replace(array('; ',' ;'), ';', $content); $content = str_replace(array(', ',' ,'), ',', $content); return str_replace(': ', ':', $content); } function css($shaName, array $chunks, $bundlePath, array $resources){ ob_start(); loadResource($resources, $chunks, 'first_css', $bundlePath); loadResource($resources, $chunks, 'bundle_css', $bundlePath, ''); loadResource($resources, $chunks, 'module_css', $bundlePath, $chunks[2] . '/'); loadResource($resources, $chunks, '_css', $bundlePath); $allCss = ob_get_clean(); if('' == $allCss) return status('No CSS', 'cyan'); $allCss = cleanCss($allCss); $pathAndFile = CACHE_PATH . 'css/' . $shaName; $fp = fopen($pathAndFile, 'w'); fwrite($fp, $allCss); fclose($fp); exec('gzip -f -9 ' . $pathAndFile); return status('CSS'); } function js($shaName, array $chunks, $bundlePath, array $resources){ ob_start(); loadResource($resources, $chunks, 'first_js', $bundlePath); loadResource($resources, $chunks, 'bundle_js', $bundlePath, ''); loadResource($resources, $chunks, 'module_js', $bundlePath . $chunks[2] . '/'); loadResource($resources, $chunks, '_js', $bundlePath); $allJs = ob_get_clean(); if('' == $allJs) return status('No JS', 'cyan'); $pathAndFile = CACHE_PATH . 'js/' . $shaName; $fp = fopen($pathAndFile, 'w'); fwrite($fp, $allJs); fclose($fp); exec('jamvm -Xmx32m -jar ../lib/yuicompressor-2.4.8.jar ' . $pathAndFile . ' -o ' . $pathAndFile . ' --type js; gzip -f -9 ' . $pathAndFile); return status('JS'); } function loadResource(array $resources, array $chunks, $key, $bundlePath, $path = true){ if(isset($resources[$key])) { $type = substr(strrchr($key, '_'), 1); $path = $bundlePath . (($path) ? $chunks[2] . '/resources/' . $type . '/' : $path . 'resources/' . $type . '/'); foreach($resources[$key] as $resource) { if(false === strpos($resource, 'http')) echo file_get_contents($path . $resource . '.' . $type); else { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $resource . '.' . $type); curl_setopt($ch, CURLOPT_HEADER, false); curl_exec($ch); curl_close($ch); } } } } function template($shaName, $route, array $resources){ if(!isset($resources['template'])) return status('No TEMPLATE', 'cyan'); ob_start(); call_user_func('bundles\\' . \config\Routes::$default['bundle'] . '\\Init::Init'); \lib\myLibs\Router::get($route); $content = ob_get_clean(); $pathAndFile = CACHE_PATH . 'tpl/' . $shaName; $fp = fopen($pathAndFile, 'w'); fwrite($fp, preg_replace('/>\s+</', '><', $content)); fclose($fp); exec('gzip -f -9 ' . $pathAndFile); return status('TEMPLATE'); } <?php namespace lib\packerjs; class JavaScriptPacker { const IGNORE = '$1'; private $_script = '', $_encoding = 62, $_fastDecode = true, $_specialChars = false, $LITERAL_ENCODING = array( 'None' => 0, 'Numeric' => 10, 'Normal' => 62, 'High ASCII' => 95 ), $_parsers = array(), $_count = array(); public function __construct($_script, $_encoding = 62, $_fastDecode = true, $_specialChars = false) { $this->_script = $_script . "\n"; if (array_key_exists($_encoding, $this->LITERAL_ENCODING)) $_encoding = $this->LITERAL_ENCODING[$_encoding]; $this->_encoding = min((int) $_encoding, 95); $this->_fastDecode = $_fastDecode; $this->_specialChars = $_specialChars; } public function pack() { $this->_addParser('_basicCompression'); if ($this->_specialChars) $this->_addParser('_encodeSpecialChars'); if ($this->_encoding) $this->_addParser('_encodeKeywords'); return $this->_pack($this->_script); } private function _pack($script) { for ($i = 0; isset($this->_parsers[$i]); $i+=1) { $script = call_user_func(array(&$this, $this->_parsers[$i]), $script); } return $script; } private function _addParser($parser) { $this->_parsers[] = $parser; } private function _basicCompression($script) { $parser = new ParseMaster(); $parser->escapeChar = '\\'; $parser->add('/\'[^\'\\n\\r]*\'/', self::IGNORE); $parser->add('/"[^"\\n\\r]*"/', self::IGNORE); $parser->add('/\\/\\/[^\\n\\r]*[\\n\\r]/', ' '); $parser->add('/\\/\\*[^*]*\\*+([^\\/][^*]*\\*+)*\\//', ' '); $parser->add('/\\s+(\\/[^\\/\\n\\r\\*][^\\/\\n\\r]*\\/g?i?)/', '$2'); $parser->add('/[^\\w\\x24\\/\'"*)\\?:]\\/[^\\/\\n\\r\\*][^\\/\\n\\r]*\\/g?i?/', self::IGNORE); if ($this->_specialChars) $parser->add('/;;;[^\\n\\r]+[\\n\\r]/'); $parser->add('/\\(;;\\)/', self::IGNORE); $parser->add('/;+\\s*([};])/', '$2'); $script = $parser->exec($script); $parser->add('/(\\b|\\x24)\\s+(\\b|\\x24)/', '$2 $3'); $parser->add('/([+\\-])\\s+([+\\-])/', '$2 $3'); $parser->add('/\\s+/', ''); return $parser->exec($script); } private function _encodeSpecialChars($script) { $parser = new ParseMaster(); $parser->add('/((\\x24+)([a-zA-Z$_]+))(\\d*)/', array('fn' => '_replace_name')); $regexp = '/\\b_[A-Za-z\\d]\\w*/'; $keywords = $this->_analyze($script, $regexp, '_encodePrivate'); $encoded = $keywords['encoded']; $parser->add($regexp, array( 'fn' => '_replace_encoded', 'data' => $encoded ) ); return $parser->exec($script); } private function _encodeKeywords($script) { if ($this->_encoding > 62) $script = $this->_escape95($script); $parser = new ParseMaster(); $encode = $this->_getEncoder($this->_encoding); $regexp = ($this->_encoding > 62) ? '/\\w\\w+/' : '/\\w+/'; $keywords = $this->_analyze($script, $regexp, $encode); $encoded = $keywords['encoded']; $parser->add($regexp, array( 'fn' => '_replace_encoded', 'data' => $encoded ) ); return (empty($script)) ? $script : $this->_bootStrap($parser->exec($script), $keywords); } private function _analyze($script, $regexp, $encode) { $_protected = $_encoded = $_sorted = $all = array(); preg_match_all($regexp, $script, $all); $all = $all[0]; if (!empty($all)) { $this->_count = $unsorted = $protected = $value = array(); $i = count($all); $j = 0; do { --$i; $word = '$' . $all[$i]; if (!isset($this->_count[$word])) { $this->_count[$word] = 0; $unsorted[$j] = $word; $values[$j] = call_user_func(array(&$this, $encode), $j); $protected['$' . $values[$j]] = $j++; } $this->_count[$word]++; } while ($i > 0); $i = count($unsorted); do { $word = $unsorted[--$i]; if (isset($protected[$word]) ) { $_sorted[$protected[$word]] = substr($word, 1); $_protected[$protected[$word]] = true; $this->_count[$word] = 0; } } while ($i); usort($unsorted, array(&$this, '_sortWords')); $j = 0; do { if (!isset($_sorted[$i])) $_sorted[$i] = substr($unsorted[$j++], 1); $_encoded[$_sorted[$i]] = $values[$i]; } while (++$i < count($unsorted)); } return array( 'sorted' => $_sorted, 'encoded' => $_encoded, 'protected' => $_protected); } private function _sortWords($match1, $match2) { return $this->_count[$match2] - $this->_count[$match1]; } private function _bootStrap($packed, $keywords) { $ENCODE = $this->_safeRegExp('$encode\\($count\\)'); $packed = "'" . $this->_escape($packed) . "'"; $ascii = min(count($keywords['sorted']), $this->_encoding); if (0 == $ascii) $ascii = 1; $count = count($keywords['sorted']); foreach ($keywords['protected'] as $i => $value) { $keywords['sorted'][$i] = ''; } ksort($keywords['sorted']); $keywords = "'" . implode('|', $keywords['sorted']) . "'.split('|')"; $encode = ($this->_encoding > 62) ? '_encode95' : $this->_getEncoder($ascii); $encode = $this->_getJSFunction($encode); $encode = preg_replace('/_encoding/', '$ascii', $encode); $encode = preg_replace('/arguments\\.callee/', '$encode', $encode); $inline = '\\$count' . ($ascii > 10 ? '.toString(\\$ascii)' : ''); if ($this->_fastDecode) { $decode = $this->_getJSFunction('_decodeBody'); if ($this->_encoding > 62) $decode = preg_replace('/\\\\w/', '[\\xa1-\\xff]', $decode); elseif ($ascii < 36) $decode = preg_replace($ENCODE, $inline, $decode); if (0 == $count) $decode = preg_replace($this->_safeRegExp('($count)\\s*=\\s*1'), '$1=0', $decode, 1); } $unpack = $this->_getJSFunction('_unpack'); if ($this->_fastDecode) { $this->buffer = $decode; $unpack = preg_replace_callback('/\\{/', array(&$this, '_insertFastDecode'), $unpack, 1); } $unpack = preg_replace('/"/', "'", $unpack); if ($this->_encoding > 62) $unpack = preg_replace('/\'\\\\\\\\b\'\s*\\+|\\+\s*\'\\\\\\\\b\'/', '', $unpack); if ($ascii > 36 || $this->_encoding > 62 || $this->_fastDecode) { $this->buffer = $encode; $unpack = preg_replace_callback('/\\{/', array(&$this, '_insertFastEncode'), $unpack, 1); } else $unpack = preg_replace($ENCODE, $inline, $unpack); $unpackPacker = new JavaScriptPacker($unpack, 0, false, true); $unpack = $unpackPacker->pack(); $params = array($packed, $ascii, $count, $keywords); if ($this->_fastDecode) { $params[] = 0; $params[] = '{}'; } $params = implode(',', $params); return 'eval(' . $unpack . '(' . $params . "))\n"; } private $buffer; private function _insertFastDecode($match) { return '{' . $this->buffer . ';'; } private function _insertFastEncode($match) { return '{$encode=' . $this->buffer . ';'; } private function _getEncoder($ascii) { return $ascii > 10 ? $ascii > 36 ? $ascii > 62 ? '_encode95' : '_encode62' : '_encode36' : '_encode10'; } private function _encode10($charCode) { return $charCode; } private function _encode36($charCode) { return base_convert($charCode, 10, 36); } private function _encode62($charCode) { $res = ''; if ($charCode >= $this->_encoding) $res = $this->_encode62((int) ($charCode / $this->_encoding)); $charCode = $charCode % $this->_encoding; return ($charCode > 35) ? $res . chr($charCode + 29) : $res . base_convert($charCode, 10, 36); } private function _encode95($charCode) { $res = ''; if ($charCode >= $this->_encoding) $res = $this->_encode95($charCode / $this->_encoding); return $res . chr(($charCode % $this->_encoding) + 161); } private function _safeRegExp($string) { return '/' . preg_replace('/\$/', '\\\$', $string) . '/'; } private function _encodePrivate($charCode) { return '_' . $charCode; } private function _escape($script) { return preg_replace('/([\\\\\'])/', '\\\$1', $script); } private function _escape95($script) { return preg_replace_callback( '/[\\xa1-\\xff]/', array(&$this, '_escape95Bis'), $script ); } private function _escape95Bis($match) { return '\x' . ((string) dechex(ord($match))); } private function _getJSFunction($aName) { return (defined('self::JSFUNCTION' . $aName)) ? constant('self::JSFUNCTION' . $aName) : ''; } const JSFUNCTION_unpack = 'function($packed, $ascii, $count, $keywords, $encode, $decode) {
    while ($count--) {
        if ($keywords[$count]) {
            $packed = $packed.replace(new RegExp(\'\\\\b\' + $encode($count) + \'\\\\b\', \'g\'), $keywords[$count]);
        }
    }
    return $packed;
}'; const JSFUNCTION_decodeBody = '    if (!\'\'.replace(/^/, String)) {
        // decode all the values we need
        while ($count--) {
            $decode[$encode($count)] = $keywords[$count] || $encode($count);
        }
        // global replacement function
        $keywords = [function ($encoded) {return $decode[$encoded]}];
        // generic match
        $encode = function () {return \'\\\\w+\'};
        // reset the loop counter -  we are now doing a global replace
        $count = 1;
    }
'; const JSFUNCTION_encode10 = 'function($charCode) {
    return $charCode;
}'; const JSFUNCTION_encode36 = 'function($charCode) {
    return $charCode.toString(36);
}'; const JSFUNCTION_encode62 = 'function($charCode) {
    return ($charCode < _encoding ? \'\' : arguments.callee(parseInt($charCode / _encoding))) +
    (($charCode = $charCode % _encoding) > 35 ? String.fromCharCode($charCode + 29) : $charCode.toString(36));
}'; const JSFUNCTION_encode95 = 'function($charCode) {
    return ($charCode < _encoding ? \'\' : arguments.callee($charCode / _encoding)) +
        String.fromCharCode($charCode % _encoding + 161);
  }'; } class ParseMaster { public $ignoreCase = false, $escapeChar = ''; const EXPRESSION = 0, REPLACEMENT = 1, LENGTH = 2; private $GROUPS = '/\\(/', $SUB_REPLACE = '/\\$\\d/', $INDEXED = '/^\\$\\d+$/', $TRIM = '/([\'"])\\1\\.(.*)\\.\\1\\1$/', $ESCAPE = '/\\\./', $QUOTE = '/\'/', $DELETED = '/\\x01[^\\x01]*\\x01/', $_escaped = array(), $_patterns = array(), $buffer; public function add($expression, $replacement = '') { $length = 1 + preg_match_all($this->GROUPS, $this->_internalEscape((string) $expression), $out); if (is_string($replacement)) { if (preg_match($this->SUB_REPLACE, $replacement)) { if (preg_match($this->INDEXED, $replacement)) { $replacement = (int) (substr($replacement, 1)) - 1; } else { $quote = preg_match($this->QUOTE, $this->_internalEscape($replacement)) ? '"' : "'"; $replacement = array( 'fn' => '_backReferences', 'data' => array( 'replacement' => $replacement, 'length' => $length, 'quote' => $quote ) ); } } } if (!empty($expression)) $this->_add($expression, $replacement, $length); else $this->_add('/^$/', $replacement, $length); } public function exec($string) { $this->_escaped = array(); $regexp = '/'; foreach ($this->_patterns as $reg) { $regexp .= '(' . substr($reg[self::EXPRESSION], 1, -1) . ')|'; } $regexp = substr($regexp, 0, -1) . '/'; $regexp .= ($this->ignoreCase) ? 'i' : ''; $string = $this->_escape($string, $this->escapeChar); $string = preg_replace_callback( $regexp, array( &$this, '_replacement' ), $string ); $string = $this->_unescape($string, $this->escapeChar); return preg_replace($this->DELETED, '', $string); } public function reset() { $this->_patterns = array(); } private function _add() { $arguments = func_get_args(); $this->_patterns[] = $arguments; } private function _replacement($arguments) { if (empty($arguments)) return ''; $i = 1; $j = 0; while (isset($this->_patterns[$j])) { $pattern = $this->_patterns[$j++]; if (isset($arguments[$i]) && ($arguments[$i] != '')) { $replacement = $pattern[self::REPLACEMENT]; if (is_array($replacement) && isset($replacement['fn'])) { if (isset($replacement['data'])) $this->buffer = $replacement['data']; return call_user_func(array(&$this, $replacement['fn']), $arguments, $i); } else if (is_int($replacement)) return $arguments[$replacement + $i]; $delete = ('' == $this->escapeChar || strpos($arguments[$i], $this->escapeChar) === false) ? '' : "\x01" . $arguments[$i] . "\x01"; return $delete . $replacement; } else $i += $pattern[self::LENGTH]; } } private function _backReferences($match, $offset) { $replacement = $this->buffer['replacement']; $quote = $this->buffer['quote']; $i = $this->buffer['length']; while ($i) { $replacement = str_replace('$' . $i--, $match[$offset + $i], $replacement); } return $replacement; } private function _replace_name($match, $offset) { $length = strlen($match[$offset + 2]); $start = $length - max($length - strlen($match[$offset + 3]), 0); return substr($match[$offset + 1], $start, $length) . $match[$offset + 4]; } private function _replace_encoded($match, $offset) { return $this->buffer[$match[$offset]]; } private function _escape($string, $escapeChar) { if ($escapeChar) { $this->buffer = $escapeChar; return preg_replace_callback( '/\\' . $escapeChar . '(.)' . '/', array(&$this, '_escapeBis'), $string ); } else return $string; } private function _escapeBis($match) { $this->_escaped[] = $match[1]; return $this->buffer; } private function _unescape($string, $escapeChar) { if ($escapeChar) { $regexp = '/' . '\\' . $escapeChar . '/'; $this->buffer = array('escapeChar' => $escapeChar, 'i' => 0); return preg_replace_callback($regexp, array(&$this, '_unescapeBis'), $string); } else return $string; } private function _unescapeBis() { $temp = (isset($this->_escaped[$this->buffer['i']]) && '' != $this->_escaped[$this->buffer['i']]) ? $this->_escaped[$this->buffer['i']] : ''; $this->buffer['i']++; return $this->buffer['escapeChar'] . $temp; } private function _internalEscape($string) { return preg_replace($this->ESCAPE, '', $string); } } ?>
