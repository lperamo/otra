////
/// Theming component.
///
/// @group Theming
/// @access public
/// @since 1.2
/// @author Lionel PÃ©ramo
////

// loading sass modules
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';

// loading utilities
@use '../../components/utils/utils';

// initializing an array that will be used to determine which values to pass to the components
$themes : ();

// initializing an array that will be passed to the global-mass-theme mixin
$to-theme: ();

// Only used for debug purposes
$processing-theme : '';

///
/// Loads a user defined theme in the 'static' variables $themes.
///
/// @access public
/// @param  {map} $_themes
///
@mixin init-themes($_themes) {
  $themes : map.merge($themes, $_themes) !global;
}

///
/// Used by the other mixins of this component, this applies a given theme for a given property
///
/// @access public
/// @param  {map}    $theme                      - The theme 'light' or 'dark'.
/// @param  {string} $property
/// @param  {string} $color
/// @param  {string} $additionalPropertiesBefore [''] Will be put at the beginning of the value
/// @param  {string} $additionalPropertiesAfter  [''] Will be put at the end of the value
///
@mixin theme-property($theme, $property, $color, $additionalPropertiesBefore: '', $additionalPropertiesAfter: '') {
  $darkenPosition : str-index($additionalPropertiesBefore, 'darken');
  $lightenPosition : str-index($additionalPropertiesBefore, 'lighten');

  @if ($darkenPosition != null) { // darken function used
    $color : darken(map-get($theme, $color), $additionalPropertiesAfter);
    $additionalPropertiesBefore : str-slice($additionalPropertiesBefore, 0, $darkenPosition - 1);

    @if ($additionalPropertiesBefore != '') {
      $additionalPropertiesBefore : $additionalPropertiesBefore + ' ';
    }

    #{$property}: unquote($additionalPropertiesBefore + $color);
  }

  @else if($lightenPosition != null) { // lighten function used
    $color : lighten(map-get($theme, $color), $additionalPropertiesAfter);
    $additionalPropertiesBefore : str-slice($additionalPropertiesBefore, 0, $lightenPosition - 1) + ' ';

    @if ($additionalPropertiesBefore != '') {
      $additionalPropertiesBefore : $additionalPropertiesBefore + ' ';
    }

    #{$property}: unquote($additionalPropertiesBefore + $color);
  }

  @else {
    @if ($additionalPropertiesAfter != '') {
      $additionalPropertiesAfter : ' ' + $additionalPropertiesAfter;
    }

    #{$property}: unquote($additionalPropertiesBefore + map-get($theme, $color) + $additionalPropertiesAfter);
  }
}

///
/// Launched inside a rule, applies a theme for a given properties
///
/// @access public
/// @param  {string} $property
/// @param  {string} $color
/// @param  {string} $additionalPropertiesBefore [''] Will be put at the beginning of the value
/// @param  {string} $additionalPropertiesAfter  [''] Will be put at the end of the value
///
@mixin theme($property, $color, $additionalPropertiesBefore : '', $additionalPropertiesAfter : '') {
  @media (prefers-color-scheme : light), (prefers-color-scheme : no-preference) {
    @include theme-property(map-get($themes, 'light'), $property, $color, $additionalPropertiesBefore, $additionalPropertiesAfter);
  }

  @media (prefers-color-scheme : dark) {
    @include theme-property(map-get($themes, 'dark'), $property, $color, $additionalPropertiesBefore, $additionalPropertiesAfter);
  }
}

///
/// Fills the third and the fourth element of a list with ''
/// SASS removes a dimension if the list contains only one element, so we treat this particular case in an if statement
///
/// @access private
/// @param  {list} $property-to-theme
///
/// @return {list} $property-to-theme
///
@function _fill-list-with-empty-strings($property-to-theme) {
  @if (list.length($property-to-theme) == 2) {
    $property-to-theme: list.append($property-to-theme, '');
    $property-to-theme: list.append($property-to-theme, '');
  }

  @else if (list.length($property-to-theme) == 3) {
    $property-to-theme: list.append($property-to-theme, '');
  }

  @return $property-to-theme;
}

///
/// Internal function to determine which color code to use (code passed, default component code ...)
///
/// @access private
/// @param  {map}    $theme  - The theme 'light' or 'dark'.
/// @param  {string} $suffix - Suffix put after all the selectors
/// @param  {string} $color
///
/// @return {list} $property-to-theme
///
@function _get-color-code($theme, $suffix, $color, $themeUsed) {
  // testing if color code exists in the themes map
  $suffixed-color : $color + $suffix;

  // Is there a color code for the suffix provided with the class?
  @if ($themeUsed and $suffixed-color != $color and map.get($theme, $suffixed-color) != null) {
    $color : $suffixed-color;
  }

  // Is there a color code without suffix for this component?
  @else if (not $themeUsed or map.get($theme, $color) == null) {
    $default-color : 'default--' + $color;

    // Do we need the default component color code?
    @if (map.get($theme, $default-color) != null) {
      $color : $default-color;
    }

    @else {
      @error "Cannot set the color. Problem can be : - The color '" + $suffixed-color + "' does not exist in your " +
        $processing-theme +
        " theme map - you did not use a correct syntax - you wanted to use defaults values but there are no default values for this component - you set `null` for this color";
    }
  }

  @return $color;
}

///
/// Launched inside a rule, it sets the theme for an array of properties for a given theme ('light' or 'dark' list)
///
/// @access public
/// @param  {map}     $theme               - The theme 'light' or 'dark'.
/// @param  {list}    $properties-to-theme
///
@mixin mass-theme-properties($theme, $properties-to-theme) {
  $suffix : list.nth($properties-to-theme, 1);
  $themeUsed : list.nth($properties-to-theme, 2);
  $properties-to-theme: utils.from-range($properties-to-theme, 3);

  // Checks if there is only one property to theme
  @if (type-of(list.nth($properties-to-theme, 1)) != 'list') {
    $properties-to-theme : append((), $properties-to-theme);
  }

  // Now we are sure there are at least two properties to theme
  @each $property-to-theme in $properties-to-theme {
    $property-to-theme: _fill-list-with-empty-strings($property-to-theme);

    @include theme-property(
      $theme,
      list.nth($property-to-theme, 1), // property
      _get-color-code($theme, $suffix, list.nth($property-to-theme, 2), $themeUsed),
      list.nth($property-to-theme, 3), // before
      list.nth($property-to-theme, 4)  // after
    );
  }
}

///
/// Launched inside a rule, sets the both themes ('light' and 'dark') for an array of properties.
///
/// @access public
/// @param  {list}    $properties-to-theme
/// @param  {string}  $suffix              ['']    - Suffix put after all the selectors
/// @param  {bool}    $themeUsed           [false] - Are we using a theme?
///
@mixin mass-theme($properties-to-theme, $suffix: '', $themeUsed: false) {
  $properties-to-theme : list.join(($suffix, $themeUsed), $properties-to-theme);

  @media (prefers-color-scheme : light), (prefers-color-scheme : no-preference) {
    $processing-theme : 'light' !global;

    @include mass-theme-properties(map-get($themes, 'light'), $properties-to-theme);
  }

  @media (prefers-color-scheme : dark) {
    $processing-theme : 'dark' !global;

    @include mass-theme-properties(map-get($themes, 'dark'), $properties-to-theme);
  }
}

///
/// Uses blend modes to adjust theming on background images.
///
/// @access public
/// @param {string} $image
/// @param {string} $after      ['']
/// @param {string} $blend-mode ['soft-light']
///
@mixin blend-image($image, $after : '', $blend-mode : 'soft-light') {
  @media (prefers-color-scheme : light), (prefers-color-scheme : no-preference) {
    background : url(unquote($image)) unquote($after);
  }

  @media (prefers-color-scheme : dark) {
    background            : linear-gradient(#000, #000), url(unquote($image)) unquote($after);
    background-blend-mode : unquote($blend-mode), normal;
  }
}

///
/// Applies themes for rules and properties stored in the $to-theme 'static' variable.
///
/// @access public
///
@mixin global-mass-theme() {
  @media (prefers-color-scheme : light), (prefers-color-scheme : no-preference) {
    $processing-theme : 'light' !global;

    @each $rule, $properties in $to-theme {
      #{$rule} {
        @include mass-theme-properties(map-get($themes, 'light'), $properties);
      }
    }
  }

  @media (prefers-color-scheme : dark) {
    $processing-theme : 'dark' !global;

    @each $rule, $properties in $to-theme {
      #{$rule} {
        @include mass-theme-properties(map-get($themes, 'dark'), $properties);
      }
    }
  }
}

///
/// Add themes to the 'static' variables $themes.
///
/// @access public
///
/// @param {map} $_themes
///
@mixin add-themes($_themes) {
  $themes : map.deep-merge($themes, $_themes) !global;
}

///
/// Adds rules for the global-mass-theme mixin.
///
/// @access public
///
/// @param {map}    $_to_theme
/// @param {string} $suffix    ['']    - Suffix put after all the selectors
/// @param {bool}   $suffix    [false] - Are we using a theme?
///
@mixin to-theme($_to-theme, $suffix: '', $themeUsed: true) {
  $rule : list.nth(map.keys($_to-theme), 1);
  $properties : list.nth(list.nth($_to-theme, 1), 2);
  $tempMap: $to-theme;

  @each $rule, $properties in $_to-theme {
    $rule : list.nth(map.keys($_to-theme), 1);
    $properties : list.nth($_to-theme, 1);
    $properties : utils.from-range($properties, 2);

    // `break` and `continue` statements do not exist in SASS so we make a for loop that go until a certain length but
    // we will affect the index to this length to stop the loop when needed!
    $list-length : list.length($to-theme);

    @if ($list-length > 0) {
      @for $i from 1 through $list-length {
        $storedRule : list.nth(map.keys($to-theme), $i);

        @if ($storedRule == $rule) {
          $i : $list-length;
          $storedProperties : list.nth(list.nth($to-theme, $i), 2);
          $storedAttributes : utils.from-range($storedProperties, 1, 2);
          $storedCssProperties : utils.from-range($storedProperties, 3);

          @if (list.nth($storedProperties, 1) == $suffix
          and list.nth($storedProperties, 2) == $themeUsed) {
            // $storedCssProperties and $properties are not in an explicit list so we need to force it with `append`
            // and then we put all that into a list
            $isList : type-of(list.nth($storedCssProperties, 1)) == 'list';
            $toJoin: ();

            // CASE 1: The two lists ($storedCssProperties and $properties) has more than one set
            // like ('..', '...'), ('..', '..')
            @if $isList and type-of(list.nth($properties, 1)) == 'list' {
              $toJoin: join($storedCssProperties, $properties);
            }

            // CASE 2: The $storedCssProperties list has more than one set like ('..', '...'), ('..', '..')
            @else if $isList {
              $toJoin: append($storedCssProperties, $properties);
            }

            // CASE 3 : The $storedCssProperties list contains only one set
            // like ('border-style', 'vertical-menu--element--border-style')
            @else {
              $toJoin : append((), join(append((), $storedCssProperties), append((), $properties)))
            }

            $blockToAppend : ($rule: list.join($storedAttributes, $toJoin));
            $tempMap: map.merge($tempMap, $blockToAppend);
          }
        }

        @else {
          $tempMap: map.merge($tempMap, ($rule : ($suffix, $themeUsed, $properties)));
        }
      }
    }

    @else {
      $tempMap: map.merge($tempMap, ($rule : ($suffix, $themeUsed, $properties)));
    }
  }

  @if ($tempMap != ()) {
    $to-theme : $tempMap !global;
  }
}
